컴퓨터 구조

# 1. 컴퓨터 구조 시작하기

## 1. 컴퓨터가 이해하는 정보

1.  데이터
    - 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    - 컴퓨터와 주고받는/내부에 저장된 정보를 데이터라 통칭하기도
    - 0과 1로 숫자를 표현하는 방법
    - 0과 1로 문자를 표현하는 방법
2.  명령어
    - 컴퓨터는 결국 명령어를 처리하는 기계
    - 명령어
      - 컴퓨터를 실질적으로 움직이는 정보
      - 데이터는 명령어를 위한 일종의 재료
    - 명령어의 생김새와 동작 방식
    - ex) '1'과 '2'를 더해라.
      - '1','2' 는 데이터.
      - '더하라' 는 명령어.
    - ex) '안녕하세요'를 출력하라
      - '안녕하세요'는 데이터.
      - '출력하라'는 명령어.

## 2. 컴퓨터의 네 가지 핵심 부품

1.  `CPU`

    - CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 부품이다. (컴퓨터의 두뇌)
    - CPU의 핵심적인 내부 구성 부품 3가지

      - `ALU` : 산술 논리 연산 장치
        - 계산기
      - `제어장치` : 컨트롤 유닛
        - 제어 신호를 내보내고, 명령어를 해석하는 장치
          - 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호
          - 제어 신호의 종류 대표적인 2가지
            - `메모리 읽기 신호` : CPU가 저장된 값을 읽고 싶을 땐 메모리를 향해 메모리 읽기라는 제어 신호를 보낸다.
            - `메모리 쓰기 신호` : CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 메모리 쓰기라는 제어 신호를 보낸다.
      - `레지스터` (여러개 존재)
        - CPU 내부의 작은 저장장치

      ```markdown
      메모리 1번지 : 더하라, 3번지와 4번지를
      메모리 2번지 : 저장하라, 연산 결과를
      메모리 3번지 : 120
      메모리 4번지 : 100
      메모리 5,6번지 : 비어있음.

      1. CPU의 제어장치가 메모리 1번지를 향해서 메모리 읽기라고 하는 제어 신호를 내보냄.
         1. 메모리 1번지에 저장되어 있는 명령어를 CPU의 레지스터 즉, CPU의 내부에 있는 작은 저장장치로 갖다 주게 됨.
         2. 레지스터에 저장된 명령어를 제어장치가 해석함.
      2. 제어장치는 '3번지와 4번지에 저장된 데이터가 필요하겠구나' 라고 판단함. (100, 120)
      3. 제어장치는 메모리 읽기 신호를 보내서 필요한 데이터를 한 번 더 갖고 오게 된다.
         1. 3번지, 4번지에 있는 데이터가 레지스터에 저장됨.
      4. 제어장치가 ALU에게 데이터를 더하라고 지시함.
         1. ALU는 데이터를 가지고 더하라는 명령어를 실행한 뒤에 결과값을 레지스터에 담는다. (100 + 120 = 220)
      5. 제어장치는 메모리 2번지를 향해 메모리 읽기 신호를 보낸다.
         1. 메모리 2번지에 저장되어 있는 명령어가 레지스터에 저장됨.
         2. 레지스터에 저장된 명령어를 제어장치가 해석함.
      6. 제어장치는 '계산 결과인 220을 메모리에 저장해야겠구나'라고 판단함.
      7. 제어장치는 쓰기 신호와 함께 결과값을 메모리에 저장하게 된다.
      ```

2.  `메모리`
    - 주기억장치 or 메인 메모리
      1. `RAM` (이 책에서는 RAM을 지칭)
         - 현재 실행되고 있는 명령어와 데이터가 저장
           - 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다.
           - 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다.
           - 메모리에 저장된 값의 위치는 주소로 알 수 있다.
      2. ROM
3.  `보조기억장치`
    - 보조기억장치가 필요한 이유
      - 메모리는 (보조기억장치에 비해) 비싸다.
      - 메모리는 전원이 꺼지면 저장된 데이터가 날아감(휘발성).
    - 메모리는 실행할 정보를 저장, 보조기억장치는 보관할 정보를 저장.
4.  `입출력장치`
    - 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품.
      - 모니터, 키보드, 마우스 등.

> `메인보드`

- 4가지 핵심부품을 연결할 수 있는 판.
- 메인보드에 연결된 부품들은 버스를 통해 정보를 주고 받는다.
  - 버스는 컴퓨터의 부품끼리 정보를 주고받는 일종의 통로
  - 다양한 종류의 버스가 있음.
  - 중요한 역할을 하는 버스, 가장 중요한 버스(사람에 비유하면 척추), 컴퓨터의 핵심 부품을 연결하는 버스는 `시스템 버스`라고 한다.
    - 시스템 버스의 내부 구성
      - 주소 버스 : 주소를 주고받는 통로
      - 데이터 버스 : 명령어와 데이터를 주고받는 통로
      - 제어 버스 : 제어 신호를 주고받는 통로
    - 메모리 값 읽기
      - 제어장치는 `주소 버스에 읽고자 하는 주소(1번지)를 담고`, `제어 버스에 메모리 읽기 신호를 담아`서 메모리로 보낸다.
      - 메모리는 `[1번지 + 읽기]를 받고 '아 1번지를 읽고 싶구나' 판단.`
      - 메모리는 `데이터 버스에 데이터를 담아`서 레지스터로 보낸다.
    - 메모리 값 쓰기
      - 제어장치는 `주소 버스에 쓰고자 하는 주소(5번지)를 담고`, `제어 버스에 메모리 쓰기 신호을 담고`, `데이터 버스에 220이라는 결과값을 담아`서 메모리로 보낸다.
      - 메모리는 `[5번지 + 쓰기 + 220]을 받고 '아 5번지에 220을 쓰고싶구나' 판단.`
- 각 장치들이 시스템 버스를 통해서 정보를 주고 받는다.

# 2. 데이터

## 1. 0과 1로 숫자를 표현하는 방법

> 정보 단위

- 비트 (bit) : 0과 1을 표현하는 가장 작은 정보 단위
  - 1비트로는 0 과 1. 총 두 가지의 정보를 표현할 수 있다.
  - 2비트로는 총 4 가지, 3비트로는 총 8 가지의 정보를 표현할 수 있다.
  - n비트로 2ⁿ가지의 정보 표현 가능
  - 프로그램은 수많은 비트로 이루어져 있음
    ```markdown
    - 1바이트(byte) = 8비트(8bit)
    - 1킬로바이트(1kB) = 1000바이트(1,000byte)
    - 1메가바이트(1MB) = 1000킬로바이트(1,000kB)
    - 1기가바이트(1GB) = 1000메가바이트(1,000MB)
    - 1테라바이트(1TB) = 1000기가바이트(1,000GB)
    ```
- 워드 (word)
  - CPU가 한 번에 처리할 수 있는 정보의 크기 단위
    - CPU가 한 번에 32비트를 처리할 수 있다면 해당 CPU는 1워드는 32비트이다. 64비트를 처리할 수 있다면 1워드는 64비트이다.
  - 하프 워드 (half word) : 워드의 절반 크기
  - 풀 워드 (full word) : 워드 크기
  - 더블 워드 (double word) : 워드의 두 배 크기

1.  이진법 (binary)

    - 0과 1로 수를 표현하는 방법
      - 숫자가 1을 넘어가는 시점에 자리올림
      - 우리가 일상적으로 십진법(decimal)을 사용함
      - 이진수 8 표기 -> 1000₍₂₎ <수학적 표기 방식> or 0b1000 <코드상 표기 방식>
    - 0과 1로 음수 표현하기 : 2의 보수
      - 어떤 수를 그보다 큰 2ⁿ에서 뺀 값
        ```
        11₍₂₎보다 큰 2ⁿ = 100₍₂₎
        100₍₂₎ - 11₍₂₎ = 01₍₂₎
        11₍₂₎을 음수로 표현한 값 = 01₍₂₎
        ```
      - 모든 0과 1을 뒤집고 1을 더한 값 (더 쉬운 방법)
        ```
        11₍₂₎ -> 모든 0과 1을 뒤집기 -> 00₍₂₎
        00₍₂₎ -> 1을 더함 -> 01₍₂₎
        11₍₂₎을 음수로 표현한 값 = 01₍₂₎
        ```
      - 음수 0101₍₂₎ 과 십진수 5를 표현한 0101₍₂₎ 구분
        - 플래그(flag) 레지스터라는 CPU 내부에 있는 특별한 레지스터가 존재.
        - 플래그 레지스터가 COU내부에서 음수인지 양수인지 표기해줌.

2.  십육진법

    - 이진법으로는 숫자의 길이가 너무 길어진다.
      - 십진수 32 === 100000₍₂₎
    - 컴퓨터의 데이터를 표현할 때 십육진법도 많이 사용
      - 수가 15를 넘어가는 시점에 자리올림

    ```
    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ,,
    0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F  10 11 12 ,,
    ```

    - 십육진수 15 표기 -> 15₍₁₆₎ <수학적 표기 방식> or 0x15 <코드상 표기 방식>

## 2. 0과 1로 문자를 표현하는 방법

- 문자집합 (character set)
  - 컴퓨터가 이해할 수 있는 문자의 모음
- 인코딩 (encoding) (문자를 표현하는 방식의 국한해서 정의)
  - 코드화 하는 과정
  - 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정
- 디코딩 (decoding) (문자를 표현하는 방식의 국한해서 정의)
  - 코드를 해석하는 과정
  - 0과 1로 표현된 문자 코드로 문자로 변환하는 과정

1. 아스키 코드 (ASCII)

   - 초창기 문자 집합 중 하나
   - 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
   - 7비트로 하나의 문자 표현
     - 실제 사용하는 8비트중 1비트는 오류 검출을 위해 사용되는 패리티 비트(parity bit)
     - 2⁷개의 문자 즉 128개 정도의 문자를 ASCII 코드로 표현할 수 있다.
   - 간단한 인코딩
   - BUT 한글을 포함한 다른 언어 문자, 다양한 특수 문자 표현 불가.
     - 아스키 코드는 7비트로 하나의 문자를 표현하기에 128개보다 많은 문자를 표현할 수 없다.
     - 8비트 확장 아스키 (extended ASCII)의 등장 -> 여전히 부족

2. 언어별 인코딩 등장
   - 한글을 위한 인코딩이 필요
     - 한글의 특징
       - 알파벳을 이어 쓰면 단어가 되는 영어에 반해 초성, 중성, 종성의 조합으로 이루어진 한글
     - 완성형 인코딩 방식과 조합형 인코딩 방식이 존재
       - 완성형 인코딩 방식
         - 음절 하나하나에 코드를 부여
       - 조합형 인코딩 방식
         - 자음 모음 각각에 고유한 코드를 부여
   1. ECU-KR 방식
      - KS X 1001 KS X 1003 문자집합 기반의 한글 인코딩 방식
      - 완성형 인코딩
      - 글자 하나 하나에 2바이트 크기의 코드 부여
        - 2바이트 == 16비트 == 4자리 십육진수로 표현
      - 2300여개의 한글 표현 가능, 여전히 모든 한글을 표현하기에는 부족한 수. 쀏, 뙠, 휔 같은 한글 표현 불가
      - 이렇게 언어별 인코딩을 국가마다 하게 되면 다국어를 지원하는 프로그램을 개발할 때엔 언어별 인코딩 방식을 모두 이해해야 한다.
        - 모든 언어, 특수문자까지 통일된 문자 집합을 사용하면 어떨까? 통일된 문자 집합 & 인코딩 방식이 있다면 어떨까?
   2. 유니코드 문자 집합과 utf-8 인코딩 방식
      - 유니코드
        - 통일된 문자 집합
        - 한글, 영어, 화살표와 같은 특수 문자, 이모티콘까지 표현 가능
        - 현대 문자 표현에 있어 매우 중요한 위치
      - 유니코드의 인코딩 방식
        - utf-8, utf-16, utf-32 ,,,
      - utf-8 인코딩
        - UTF (Unicode Transformation Format) == 유니코드 인코딩 방법
        - 가변 길이 인코딩 : 인코딩 결과가 1바이트 ~ 4바이트
        - 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다름

# 3. 명령어

## 1. 소스 코드와 명령어

- 고급언어 --- 변환 ---> 저급언어
  - 고급언어
    - 프로그래밍 언어
    - 개발자가 읽고 쓰기 편하게 만들어진 언어.
  - 저급 언어
    - 컴퓨터가 이해하고 실행하는 언어.

1. 저급 언어

   1. 기계어
      - 0과 1로 이루어진 명령어로 구성된 저급 언어
      - 16진수로 표현되기도 함.
   2. 어셈블리어
      - 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

2. 고급 언어

   - 고급 언어가 저급 언어로 변환되는 방식에는 2가지가 있다.

   1. 컴파일 방식
      - 컴파일 언어로 작성된 소스 코드는 컴파일러에 의해 저급 언어로 변환되고(이 과정을 컴파일이라고 한다.), 컴파일 결과로 저급 언어인 목적 코드가 생성된다.
      - 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않음
   2. 인터프리트 방식
      - 인터프리터에 의해 한 줄씩 실행
      - 소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요 없음
      - 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행

   - 컴파일 과정

     | c언어          | 저급언어                                                                                                |
     | -------------- | ------------------------------------------------------------------------------------------------------- |
     | int main( ) {  | push rbp<br>mov rbp, rsp                                                                                |
     | int a = 1;     | mov rbp, rsp                                                                                            |
     | int b = 2;     | mov DWORD PTR [rbp-8], 2                                                                                |
     | int c = a + b; | mov edx, DWORD PTR [rbp-4]<br>mov eax, DWORD PTR [rbp-8]<br>add eax, edx<br>mov DWORD PTR [rbp-12], eax |
     | return 0;      | mov eax, 0                                                                                              |
     | }              | pop rbp<br>ret                                                                                          |

     - cpu의 종류와 컴파일러의 종류에 따라 변환된 저급 언어의 모습은 달라진다.
       - 현재 컴파일된 저급언어는 'x86-64 gcc 13.2'로 변환이 된 상태이다.
         - 'x86-64'는 CPU 종류
         - 'gcc 13.2'는 컴파일러의 종류이다.

3. 모든 언어가 컴파일 언어와 인터프리트 언어로 양분되는 개념은 아니다.
   - 컴파일 방식과 인터프리트 방식이 있는데 이 두 가지 방식은 고급 언어가 저급 언어로 변환되는 아주 대표적인 방식 중에 하나다 정도로 이해.

## 2. 명령어의 구조

- 명령어의 구조
  - 수행할 연산 | 연산에 사용될 데이터 혹은 데이터가 저장된 주소
    - ex) 더해라 | 100과 | 120을
    - ex) 빼라 | 메로리 32번지 안의 값과 | 메모리 33번지 안의 값을
    - ex) 저장해라 | 10을 | 메모리 128번지에
  - 명령어는 연산 코드와 오퍼랜드로 구성된다.

1. 연산코드

   - 연산 코드의 종류 & 생김새는 CPU 마다 다름.

   1. 데이터 전송
      - 대표적인 연산 코드의 종류
        - (암기 필요 X, 유형을 익히자.)
        - MOVE : 데이터를 옮겨라
        - STORE : 메모리에 저장하라
        - LOAD (FETCH) : 메모리에서 CPU로 데이터를 가져와라
        - PUSH : 스택에 데이터를 저장하라
        - POP : 스택의 최상단 데이터를 가져와라
          - 스택은 아래가 막혀있는 통과 같은 자료구조
            - 쌓이는 스택의 순서와 꺼내는 스택의 순서가 반대.
            - 제일 나중에 들어간 스택이 먼저 나오게 되는 자료구조
              - '라스트 인 퍼스트 아웃'
              - 줄여서 '리포'라고도 한다.
          - 큐는 양쪽 끝이 뚫려있는 호스와 같은 구조.
            - 먼저 들어간 큐가 먼저 나옴
              - '퍼스트 인 퍼스트 아웃'
              - 줄여서 '피포'라고도 한다.
   2. 산술/논리 연산
      - ADD / SUBTRACT / MULTIPLY / DIVIDE
        - 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
      - INCREMENT / DECREMENT
        - 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
      - AND / OR / NOT
        - AND / OR / NOT 연산을 수행하라
      - COMPARE
        - 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
   3. 제어 흐름 변경
      - JUMP
        - 특정 주소로 실행 순서를 옮겨라
      - CONDITIONAL JUMP
        - 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
      - HALT
        - 프로그램의 실행을 멈춰라
      - CALL
        - 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
      - RETURN
        - CALL을 호출할 때 저장했던 주소로 돌아가라
   4. 입출력 제어
      - READ (INPUT)
        - 특정 입출력 장치로부터 데이터를 읽어라
      - WRITE (OUTPUT)
        - 특정 입출력 장치로 데이터를 써라
      - START IO
        - 입출력 장치를 시작하라
      - TEST IO
        - 입출력 장치의 상태를 확인하라

2. 오퍼랜드

   - 연산에 사용될 테이터 or 연산에 사용될 데이터가 저장된 위치
     - 하지만 데이터 보다 연산에 사용될 데이터의 주소가 더 자주 저장되게 된다.
     - 그렇기 때문에 오퍼랜드 필드를 주소 필드라고 부르기도 함.
   - 오퍼랜드가 있거나 없는 경우도 있다.
     - 오퍼랜드가 없는 경우 (0-주소 명령어)
     - 한 개인 경우 (1-주소 명령어)
     - 두 개 or 세 개인 경우 (2-주소 or 3-주소 명령어)

   > 주소를 넣는 경우가 많아 주소필드라고도 불리는 오퍼랜드 필드에 왜 데이터를 넣지 않고 주소를 넣느냐?
   >
   > - 명령어 내에서 표현할 수 있는 데이터의 크기가 제한되기 때문
   >   - 16비트의 명령어 = 4비트의 연샅코드 + 2개의 오퍼랜드 (각 6비트)
   >   - 이런 경우 하나의 오퍼랜드에서 표현할 수 있는 데이터의 크기는 2⁶이다.
   >   - 오퍼랜드의 개수가 늘어날 수록 표현할 수 있는 데이터의 크기는 줄어든다.
   > - 주소를 명시할 경우 주소의 크기 만큼의 데이터를 담는 것이나 마찬가지. (메모리의 주소 or 레지스터의 주소)
   >   - 10번지의 담을 수 있는 데이터의 크기가 16비트이고, 오퍼랜드의 크기는 4비트라고 했을 때, 10번지라는 주소를 담는다면.
   >   - 16비트의 값을 오퍼랜드 필드로 표현할 수 있는 것이나 마찬가지

3. 명령어 주소 지정 방식

   - 유효 주소 (effective address)
     - 연산에 사용할 데이터가 저장된 위치
   - 명령어 주소 지정 방식 (addressing modes)
     - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
     - 유효 주소를 찾는 방법
     - 다양한 명령어 주소 지정 방식들 (cpu 마다 차이가 있음)

4. 명령어 주소 지정 방식 종류
   - 즉시 주소 지정 방식 (immediate addressing mode)
     - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
     - 가장 간단한 형태의 주소 지정 방식
     - 연산에 사용할 데이터의 크기가 작아질 수 있다.
     - 다른 주소로 접근하는 과정이 없기 때문에 빠름.
   - 직접 주소 지정 방식 (direct addressing mode)
     - 오퍼랜드 필드에 유효 주소를 직접적으로 명시
     - 유효 주소를 표현할 수 있는 크기가 줄어듦.
   - 간접 주소 지정 방식 (indirect addressing mode)
     - 오퍼랜드 필드에 유효 주소의 주소를 명시
       - 유효 주소가 담겨있는 주소를 명시하면 유효 주소를 충분히 표현 할 수 있게 됨.
         - 오퍼랜드에 담을 수 있는 크기보다 메모리에 담을 수 있는 크기가 더 크기 때문에 더 큰 유효 주소를 표현할 수 있다.
     - 앞선 주소 지정 방식들에 비해 속도가 느림
       - 메모리를 여러번 접근해야 함
   - 레지스터 주소 지정 방식 (register addressing mode)
     - 연산에 사용할 데이터가 저장된 레지스터 명시
     - 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름
   - 레지스터 간접 주소 지정 방식 (register indirect addressing mode)
     - 연산에 사용할 데이터를 메모리에 저장
     - 그 유효 주소를 레지스터에 저장
     - 유효 주소가 저장되어있는 레지스터의 주소를 오퍼랜드 필드에 명시
   - 스택 주소 지정 방식 : 스택 포인터에 따라 데이터를 읽는 방식
   - 변위 주소 지정 방식
     1. 상대 주소 지정 방식
        - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
     2. 베이스 레지스터 주소 지정 방식
        - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

## 3. (추가) 소스 코드가 명령어가 되기까지

> **C 언어 컴파일 과정**
>
> 소스코드 -> [전처리기(preprocessor)] -> [컴파일러(compiler)] -> [어셈블러(assembler)] -> [링커(linker)] -> 실행파일
>
> test.c -> 전처리 -> 컴파일 -> 어셈블 -> 링킹 -> test.exe

1. 전처리 과정 (preprocessing)

   - 본격적으로 컴파일하기 전 준비작업
   - 외부에 선언된 다양한 소스 코드, 라이브러리 포함 (e.g. #include)
   - 프로그래밍의 편의를 위해 작성된 매크로 변환 (e.g. #define)
   - 컴파일할 영역 명시 (e.g. #if, #ifdef ,,,)

   > 예를들어

   ```c++
   #include <stdio.h>

   int main() {
       printf("hello, world!\n");
       return 0;
   }
   ```

   > 위와 같은 소스 코드가 있다면 'stdio.h'라는 일종의 소스코드의
   > 내용을 해당 소스코드로 가져오는, 포함시키는 과정이 전처리 과정의
   > 일부이다. 컴파일 하기위한 준비.

2. 컴파일 과정 (compiling)

   - 전처리가 완료 되어도 여전히 소스 코드.
   - 전처리가 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환
   - 어셈블리 언어는 CPU마다 컴파일러마다 형태가 다를 수 있다.

3. 어셈블 과정 (assembling)

   - 어셈블리어를 기계어로 변환
   - 목적 코드(object file)를 포함하는 목적 파일이 된다.

   > **목적 파일 vs 실행 파일**
   >
   > 목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일
   >
   > But, 목적 파일과 실행 파일은 다르다.
   >
   > 목적 파일은 링킹(linking)을 거친 이후에야 실행 파일이 된다.

4. 링킹 과정 (linking)
   - 각기 다른 목적 코드를 하나의 실행 파일로 묶어주는 작업 즉, 연결 시켜주는 작업이 링킹
   - 링킹을 거친 후에 실행 파일이 된다.

# 4. CPU의 작동 원리

## 1. ALU와 제어장치

- CPU는 ALU, 제어장치, 레지스터 등으로 구성.
- ALU는 계산하는 장치
- 제어장치는 제어 신호를 발생시키고 명령어를 해석하는 장치

1. ALU

   - 받아들이는 정보
     - 계산을 하기 위해 피연산자와 수행할 연산이 필요
     - 레지스터로부터 피연산자, 제어장치로부터 제어신호를 받아들인다.
   - 내보내는 정보
     - 계산을 완료하고 결괏값을 내보낸다.
     - 결괏값을 레지스터, 플래그를 플래그 레지스터로 보내준다.
       - CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 빠르기 때문에 레지스터에 담는다.
       - 플래그는 연산 결과에 대한 부가정보이다.
         - 부호 플래그 : 연산한 결과의 부호(1:-,0:+)
         - 제로 플래그 : 연산 결과가 0인지의 여부(1:0,0:0x)
         - 캐리 플래그 : 올림수나 빌림수의 발생 여부(1:발생,0:발생x)
         - 오버플로우 플래그 : 오버플로우 여부(1:발생,0:발생x)
         - 인터럽트 플래그 : 인터럽트 가능 여부(1:가능,0:불가능)
         - 슈퍼바이저 플래그 : 커널 모드로 실행중인지, 사용자 모드로 실행중인지(1:커널,0:사용자)

2. 제어장치

   - 받아들이는 정보
     - 클럭 신호
       - 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게 하는 시간 단위
     - 명령어 레지스터로부터 해석할 명령어를 받아들인다.
     - 플래그 레지스터로부터 플래그를 받아들인다.
     - 제어버스를 통해 CPU외부로부터 발생한 제어 신호를 받아들인다.
   - 내보내는 정보
     - ALU, 레지스터로 제어신호를 보낸다.
       - 레지스터 : 레지스터간에 어떤 정보를 이동해라, 어떤 값을 저장해라, 어떤 행동을 해라 등과 같은 레지스터를 움직이게 하는 제어신호를 보낸다.
       - ALU : 수행할 연산을 지시하는 제어신호를 보낸다.
     - 제어버스를 통해 CPU 외부(메모리,입출력장치)로 제어 신호를 보낸다.
       - 메모리 : 메모리를 읽어라, 써라같은 제어 신호를 보낸다.
       - 입출력장치 : 읽어라, 써라, 테스트해라 같은 제어 신호를 보낸다.

## 2. 레지스터

- CPU 내부의 작은 임시저장장치
- 프로그램 속 명령어 & 데이터는 실행 전,후로 레지스터에 저장
- CPU 내부에는 다양한 레지스터들이 존재. 각기 다른 역할.
  - CPU마다 레지스터의 개수, 이름 등이 다른 경우가 있다.

1. 프로그램 카운터
   - 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어의 주소)
     - Instruction Pointer(명령어 포인터)라고 부르는 CPU도 존재.
2. 명령어 레지스터
   - 해석할 명령어 (방금 메모리에서 읽어 들인 명령어)
3. 메모리 주소 레지스터
   - 메모리의 주소
     - CPU가 읽어 들이고자 하는 주소를 주소 버스로 보낼 때 거치는 레지스터
4. 메모리 버퍼 레지스터
   - 메모리와 주고받을 값 (데이터와 명령어)
     - CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터

```markdown
- 이해하기 쉽게 프로그램을 이루는 명령어들이 각각 하나의 메모리 번지를 차지하고 있다고 가정
- 메모리 1000번지 ~ 1500번지까지 CPU가 실행하고자 하는 프로그램이 저장.
- 1000번지부터 시작한다고 가정

1. 프로그램 카운터에 1000번지가 저장된다.
   - 메모리에서 가져올 명령어의 주소가 저장되기 때문.
   - CPU는 1000번지를 실행할 예정이기 때문에 1000번지라는 주소가 프로그램 카운터에 저장.
2. 메모리 주소 레지스터에 1000번지가 담긴다.
   - CPU는 메모리의 1000번지로부터 명령어를 가져오려한다.
   - 주소버스를 통해 읽고자 하는 주소를 메모리로 보내주어야한다.
   - 그때 메모리 주소 레지스터를 거치기 때문에 메모리 주소 레지스터에 주소가 복사된다.
3. CPU는 메모리 주소 레지스터를 거쳐서 주소 버스를 통해 메모리 주소를, 제어 버스를 통해 제어신호(메모리 읽기)를 보낸다.
4. 해당 주소로 제어 신호를 받은 메모리는 저장된 값을 데이터 버스를 통해 메모리 버퍼 레지스터에 전달해주게 된다.
5. 프로그램 카운터는 1이 증가된다.
   - 다음으로 실행할 주소가 저장.
6. 메모리 버퍼 레지스터에 담긴 명령어를 해석하기 위해 해당 명령어가 명령어 레지스터에 담긴다.
```

> 프로그램 카운터가 1씩 증가하는 것이 프로그램을 순차적으로 실행할 수 있는 원리가 된다.
>
> <U>프로그램의 순차적인 실행 흐름이 끊기는 경우</U>
>
> - 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
>
>   - (e.g. JUMP, CONDITIONAL JUMP, CALL, RET)
>
> - 인터럽트 발생 시
>
> - ETC...

5. 플래그 레지스터
   - 연산 결과 또는 CPU 상태에 대한 부가적인 정보
6. 범용 레지스터
   - 다양하고 일반적인 상황에서 자유롭게 사용
   - 보통 여러 개 존재.
7. 스택 포인터
   - 스택의 꼭대기를 가리키는 레지스터 (스택이 어디까지 차 있는지에 대한 표시)
   - 특정 레지스터를 이용한 주소 지정 방식에 사용됨.
     - 스택 주소 지정 방식
       - 스택과 스택 포인터를 이용한 주소 지정 방식
       - 메모리 안에 스택처럼 쓸 수 있는 미리 지정된 구역이 존재 (스택 영역)
8. 베이스 레지스터
   - 기준 주소 저장
   - 특정 레지스터를 이용한 주소 지정 방식에 사용됨.
     - 변위 주소 지정 방식
       - 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는다.
       - 보통의 명령어 구조 : 연산코드 , 오퍼랜드로 구성
       - 변위 주소 지정 방식의 명령어의 구조는 다음 꼴을 띄고 있다.
         - 연산코드 + 레지스터(어떤 레지스터와 더할지) + 오퍼랜드(변위 값)
         - 레지스터의 값과 오퍼랜드에 담긴 변위값을 더한 값이 유효 주소이다.
       - 변위 주소 지정 방식은 2가지가 있다. (CPU마다 다를 수 있음)
         1. 상대 주소 지정 방식
            - 오퍼랜드 필드 안에 있는 값과 프로그램 카운터에 있는 값을 더해서 유효주소를 얻는 방식
            - 처음으로 실행할 메모리의 주소가 담긴 프로그램 카운터에서 오퍼랜드 필드에 담긴 변위(+,-)를 더한 값의 주소가 유효주소
         2. 베이스 레지스터 주소 지정 방식
            - 오퍼랜드 필드 안에 있는 값과 베이스 레지스터에 있는 값을 더해서 유효주소를 얻는 방식
            - 베이스 레지스터에는 기준 주소가 담긴다.

## 3. 명령어 사이클과 인터럽트

- CPU는 메모리로부터 명령어나 데이터들을 갖고 와서 실행한다. 필요하다면 값을 저장할 수도 있다.
- 이러한 과정은 일정한 패턴(흐름,주기)을 가지고 있다.
  - 그것을 명령어 사이클이라고 부른다.
- CPU는 명령어 사이클에 따라 처리를 하는데 간혹 그 정해진 흐름을 방해하는 신호가 CPU한테 올 수 있다.
  - 정해진 흐름을 끊는 신호를 인터럽트라고 부른다.

1. 명령어 사이클

   - CPU는 프로그램 속의 명령어들을 일정한 주기로 반복하며 실행을 한다.
   - 이러한 주기를 명령어 사이클이라고 함.
   - 인출 사이클
     - 인출 주기
       - 인출 : CPU가 메모리 안에 있는 어떤 프로그램을 실행하기 위해서 메모리에 저장된 값을 CPU 내부로 갖고 오는 작업
   - 실행 사이클
     - 실행 주기
       - 가지고 온 값을 실행하는 주기
   - 일반적으로 CPU는 인출, 실행 사이클이 반복되며 실행된다.
   - 하지만 인출을 했지만 바로 실행할 수 없는 경우도 존재.
     - 간접 주소 지정 방식과 같은 경우.
       - 간접 주소가 10이라면 메모리 10번지에 유효 주소가 담겨있다.
         - 10번지로 가서 유효주소를 가져오고 다시 해당 주소로 접근해야함.
   - 그렇기때문에 일반적인 인출,실행 사이클을 반복하다가 메모리 접근이 더 필요한 경우 간접사이클에 돌입하게 된다.
   - 명령어 사이클은 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있다.

2. 인터럽트

   - 인터럽트 (interrupt) : 방해하다, 중단시키다.
   - CPU가 꼭 주목해야 할 때, CPU가 얼른 처리해야 할 다른 작업이 생겼을 때, 발생.
   - 인터럽드 종류

     1. 동기 인터럽트 (예외)
        - CPU가 예기치 못한 상황을 접했을 때 발생
        - 폴트, 트랩, 중단, 소프트웨어 인터럽트 이 4가지 종류가 있다.
     2. 비동기 인터럽트 (하드웨어 인터럽트)

        - 주로 입출력장치에 의해 발생 (알림이나 키보드, 마우스 같은 것들의 클릭)
        - 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트 사용
        - 입출력장치는 CPU에 비해 느리다.
        - 인터럽트가 있다면 입출력 작업 동안 CPU는 다른 일을 할 수 있다.
          - CPU가 계속해서 입출력 작업이 완료되었는지 주기적으로 확인하면서 기다릴 필요가 없음
        - 하드웨어 인터럽트의 처리 순서

          - 인터럽트의 종류에 상관없이 처리 순서는 대동소이함.

            1. 입출력 장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
            2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함.
            3. CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함.
               - 인터럽트 플래그는 플래그 레지스터에 있다.
               - 인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
            4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업.
            5. CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행
               - 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
               - 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램
            6. 인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해 둔 작업을 복구하여 실행 재개.

            > - 인터럽트 요청 신호 : 입출력장치 같은 주체들이 CPU에게 끼어들어도 되는지 요청을 보내는 신호.
            > - CPU가 인터럽트 요청 신호를 받아들였으면 실행사이클이 끝나고 항상 플래그 레지스터 속에 인터럽트 플래그를 확인한다.
            >   - 인터럽트 요청을 받아들일 수 있다면 실행하고 받아들일 수 없다면 실행하지 않는다.
            >   - 모든 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다. 하드웨어 고장, 정전 등 매우 긴급하게 처리를 해야만하는 인터럽트들도 존재.
            >   - 이렇게 막을 수 없는 인터럽트를 NMI(Non-Maskable-Interrupt)라고 한다.
            > - CPU가 인터럽트를 받아들이기로 했다면 인터럽트 서비스 루틴 실행
            >   - 인터럽트 서비스 루틴이란,
            >     - 인터럽트가 발생했을 때 해당 인터럽트를 처리하기 위한 프로그램
            >   - 인터럽트 서비스 루틴 또한 프로그램이기에 메모리에 각기 다른 루틴들이 저장되어있다.
            > - 인터럽트 벡터 : 각각의 인터럽트를 구분하기 위한 정보
            >   - 인터럽트마다 고유한 인터럽트 서비스 루틴의 시작 주소를 가지고 있다.
            >   - 인터럽트를 보내는 주체는 인터럽트 요청 신호와 함께 데이터 버스를 통해 인터럽트 벡터도 함께 보낸다.
            > - 인터럽트를 받아들이기 전 레지스터에 저장되어있는 작업들을 스택에 백업해 두게 된다.
            >   - 그 후에 인터럽트 서비스 루틴을 실행하기 위한 정보들이 레지스터에 담긴다.
            >   - 인터럽트 서비스 루틴이 실행하고 나서 스택에 있는 백업 내용을 복구한다.
