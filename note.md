컴퓨터 구조

# 1. 컴퓨터 구조 시작하기

## 1. 컴퓨터가 이해하는 정보

1.  데이터
    - 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
    - 컴퓨터와 주고받는/내부에 저장된 정보를 데이터라 통칭하기도
    - 0과 1로 숫자를 표현하는 방법
    - 0과 1로 문자를 표현하는 방법
2.  명령어
    - 컴퓨터는 결국 명령어를 처리하는 기계
    - 명령어
      - 컴퓨터를 실질적으로 움직이는 정보
      - 데이터는 명령어를 위한 일종의 재료
    - 명령어의 생김새와 동작 방식
    - ex) '1'과 '2'를 더해라.
      - '1','2' 는 데이터.
      - '더하라' 는 명령어.
    - ex) '안녕하세요'를 출력하라
      - '안녕하세요'는 데이터.
      - '출력하라'는 명령어.

## 2. 컴퓨터의 네 가지 핵심 부품

1.  `CPU`

    - CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 부품이다. (컴퓨터의 두뇌)
    - CPU의 핵심적인 내부 구성 부품 3가지

      - `ALU` : 산술 논리 연산 장치
        - 계산기
      - `제어장치` : 컨트롤 유닛
        - 제어 신호를 내보내고, 명령어를 해석하는 장치
          - 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호
          - 제어 신호의 종류 대표적인 2가지
            - `메모리 읽기 신호` : CPU가 저장된 값을 읽고 싶을 땐 메모리를 향해 메모리 읽기라는 제어 신호를 보낸다.
            - `메모리 쓰기 신호` : CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 메모리 쓰기라는 제어 신호를 보낸다.
      - `레지스터` (여러개 존재)
        - CPU 내부의 작은 저장장치

      ```markdown
      메모리 1번지 : 더하라, 3번지와 4번지를
      메모리 2번지 : 저장하라, 연산 결과를
      메모리 3번지 : 120
      메모리 4번지 : 100
      메모리 5,6번지 : 비어있음.

      1. CPU의 제어장치가 메모리 1번지를 향해서 메모리 읽기라고 하는 제어 신호를 내보냄.
         1. 메모리 1번지에 저장되어 있는 명령어를 CPU의 레지스터 즉, CPU의 내부에 있는 작은 저장장치로 갖다 주게 됨.
         2. 레지스터에 저장된 명령어를 제어장치가 해석함.
      2. 제어장치는 '3번지와 4번지에 저장된 데이터가 필요하겠구나' 라고 판단함. (100, 120)
      3. 제어장치는 메모리 읽기 신호를 보내서 필요한 데이터를 한 번 더 갖고 오게 된다.
         1. 3번지, 4번지에 있는 데이터가 레지스터에 저장됨.
      4. 제어장치가 ALU에게 데이터를 더하라고 지시함.
         1. ALU는 데이터를 가지고 더하라는 명령어를 실행한 뒤에 결과값을 레지스터에 담는다. (100 + 120 = 220)
      5. 제어장치는 메모리 2번지를 향해 메모리 읽기 신호를 보낸다.
         1. 메모리 2번지에 저장되어 있는 명령어가 레지스터에 저장됨.
         2. 레지스터에 저장된 명령어를 제어장치가 해석함.
      6. 제어장치는 '계산 결과인 220을 메모리에 저장해야겠구나'라고 판단함.
      7. 제어장치는 쓰기 신호와 함께 결과값을 메모리에 저장하게 된다.
      ```

2.  `메모리`
    - 주기억장치 or 메인 메모리
      1. `RAM` (이 책에서는 RAM을 지칭)
         - 현재 실행되고 있는 명령어와 데이터가 저장
           - 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다.
           - 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다.
           - 메모리에 저장된 값의 위치는 주소로 알 수 있다.
      2. ROM
3.  `보조기억장치`
    - 보조기억장치가 필요한 이유
      - 메모리는 (보조기억장치에 비해) 비싸다.
      - 메모리는 전원이 꺼지면 저장된 데이터가 날아감(휘발성).
    - 메모리는 실행할 정보를 저장, 보조기억장치는 보관할 정보를 저장.
4.  `입출력장치`
    - 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품.
      - 모니터, 키보드, 마우스 등.

> `메인보드`

- 4가지 핵심부품을 연결할 수 있는 판.
- 메인보드에 연결된 부품들은 버스를 통해 정보를 주고 받는다.
  - 버스는 컴퓨터의 부품끼리 정보를 주고받는 일종의 통로
  - 다양한 종류의 버스가 있음.
  - 중요한 역할을 하는 버스, 가장 중요한 버스(사람에 비유하면 척추), 컴퓨터의 핵심 부품을 연결하는 버스는 `시스템 버스`라고 한다.
    - 시스템 버스의 내부 구성
      - 주소 버스 : 주소를 주고받는 통로
      - 데이터 버스 : 명령어와 데이터를 주고받는 통로
      - 제어 버스 : 제어 신호를 주고받는 통로
    - 메모리 값 읽기
      - 제어장치는 `주소 버스에 읽고자 하는 주소(1번지)를 담고`, `제어 버스에 메모리 읽기 신호를 담아`서 메모리로 보낸다.
      - 메모리는 `[1번지 + 읽기]를 받고 '아 1번지를 읽고 싶구나' 판단.`
      - 메모리는 `데이터 버스에 데이터를 담아`서 레지스터로 보낸다.
    - 메모리 값 쓰기
      - 제어장치는 `주소 버스에 쓰고자 하는 주소(5번지)를 담고`, `제어 버스에 메모리 쓰기 신호을 담고`, `데이터 버스에 220이라는 결과값을 담아`서 메모리로 보낸다.
      - 메모리는 `[5번지 + 쓰기 + 220]을 받고 '아 5번지에 220을 쓰고싶구나' 판단.`
- 각 장치들이 시스템 버스를 통해서 정보를 주고 받는다.

# 2. 데이터

## 1. 0과 1로 숫자를 표현하는 방법

> 정보 단위

- 비트 (bit) : 0과 1을 표현하는 가장 작은 정보 단위
  - 1비트로는 0 과 1. 총 두 가지의 정보를 표현할 수 있다.
  - 2비트로는 총 4 가지, 3비트로는 총 8 가지의 정보를 표현할 수 있다.
  - n비트로 2ⁿ가지의 정보 표현 가능
  - 프로그램은 수많은 비트로 이루어져 있음
    ```markdown
    - 1바이트(byte) = 8비트(8bit)
    - 1킬로바이트(1kB) = 1000바이트(1,000byte)
    - 1메가바이트(1MB) = 1000킬로바이트(1,000kB)
    - 1기가바이트(1GB) = 1000메가바이트(1,000MB)
    - 1테라바이트(1TB) = 1000기가바이트(1,000GB)
    ```
- 워드 (word)
  - CPU가 한 번에 처리할 수 있는 정보의 크기 단위
    - CPU가 한 번에 32비트를 처리할 수 있다면 해당 CPU는 1워드는 32비트이다. 64비트를 처리할 수 있다면 1워드는 64비트이다.
  - 하프 워드 (half word) : 워드의 절반 크기
  - 풀 워드 (full word) : 워드 크기
  - 더블 워드 (double word) : 워드의 두 배 크기

1.  이진법 (binary)

    - 0과 1로 수를 표현하는 방법
      - 숫자가 1을 넘어가는 시점에 자리올림
      - 우리가 일상적으로 십진법(decimal)을 사용함
      - 이진수 8 표기 -> 1000₍₂₎ <수학적 표기 방식> or 0b1000 <코드상 표기 방식>
    - 0과 1로 음수 표현하기 : 2의 보수
      - 어떤 수를 그보다 큰 2ⁿ에서 뺀 값
        ```
        11₍₂₎보다 큰 2ⁿ = 100₍₂₎
        100₍₂₎ - 11₍₂₎ = 01₍₂₎
        11₍₂₎을 음수로 표현한 값 = 01₍₂₎
        ```
      - 모든 0과 1을 뒤집고 1을 더한 값 (더 쉬운 방법)
        ```
        11₍₂₎ -> 모든 0과 1을 뒤집기 -> 00₍₂₎
        00₍₂₎ -> 1을 더함 -> 01₍₂₎
        11₍₂₎을 음수로 표현한 값 = 01₍₂₎
        ```
      - 음수 0101₍₂₎ 과 십진수 5를 표현한 0101₍₂₎ 구분
        - 플래그(flag) 레지스터라는 CPU 내부에 있는 특별한 레지스터가 존재.
        - 플래그 레지스터가 COU내부에서 음수인지 양수인지 표기해줌.

2.  십육진법

    - 이진법으로는 숫자의 길이가 너무 길어진다.
      - 십진수 32 === 100000₍₂₎
    - 컴퓨터의 데이터를 표현할 때 십육진법도 많이 사용
      - 수가 15를 넘어가는 시점에 자리올림

    ```
    0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ,,
    0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F  10 11 12 ,,
    ```

    - 십육진수 15 표기 -> 15₍₁₆₎ <수학적 표기 방식> or 0x15 <코드상 표기 방식>

## 2. 0과 1로 문자를 표현하는 방법

- 문자집합 (character set)
  - 컴퓨터가 이해할 수 있는 문자의 모음
- 인코딩 (encoding) (문자를 표현하는 방식의 국한해서 정의)
  - 코드화 하는 과정
  - 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정
- 디코딩 (decoding) (문자를 표현하는 방식의 국한해서 정의)
  - 코드를 해석하는 과정
  - 0과 1로 표현된 문자 코드로 문자로 변환하는 과정

1. 아스키 코드 (ASCII)

   - 초창기 문자 집합 중 하나
   - 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
   - 7비트로 하나의 문자 표현
     - 실제 사용하는 8비트중 1비트는 오류 검출을 위해 사용되는 패리티 비트(parity bit)
     - 2⁷개의 문자 즉 128개 정도의 문자를 ASCII 코드로 표현할 수 있다.
   - 간단한 인코딩
   - BUT 한글을 포함한 다른 언어 문자, 다양한 특수 문자 표현 불가.
     - 아스키 코드는 7비트로 하나의 문자를 표현하기에 128개보다 많은 문자를 표현할 수 없다.
     - 8비트 확장 아스키 (extended ASCII)의 등장 -> 여전히 부족

2. 언어별 인코딩 등장
   - 한글을 위한 인코딩이 필요
     - 한글의 특징
       - 알파벳을 이어 쓰면 단어가 되는 영어에 반해 초성, 중성, 종성의 조합으로 이루어진 한글
     - 완성형 인코딩 방식과 조합형 인코딩 방식이 존재
       - 완성형 인코딩 방식
         - 음절 하나하나에 코드를 부여
       - 조합형 인코딩 방식
         - 자음 모음 각각에 고유한 코드를 부여
   1. ECU-KR 방식
      - KS X 1001 KS X 1003 문자집합 기반의 한글 인코딩 방식
      - 완성형 인코딩
      - 글자 하나 하나에 2바이트 크기의 코드 부여
        - 2바이트 == 16비트 == 4자리 십육진수로 표현
      - 2300여개의 한글 표현 가능, 여전히 모든 한글을 표현하기에는 부족한 수. 쀏, 뙠, 휔 같은 한글 표현 불가
      - 이렇게 언어별 인코딩을 국가마다 하게 되면 다국어를 지원하는 프로그램을 개발할 때엔 언어별 인코딩 방식을 모두 이해해야 한다.
        - 모든 언어, 특수문자까지 통일된 문자 집합을 사용하면 어떨까? 통일된 문자 집합 & 인코딩 방식이 있다면 어떨까?
   2. 유니코드 문자 집합과 utf-8 인코딩 방식
      - 유니코드
        - 통일된 문자 집합
        - 한글, 영어, 화살표와 같은 특수 문자, 이모티콘까지 표현 가능
        - 현대 문자 표현에 있어 매우 중요한 위치
      - 유니코드의 인코딩 방식
        - utf-8, utf-16, utf-32 ,,,
      - utf-8 인코딩
        - UTF (Unicode Transformation Format) == 유니코드 인코딩 방법
        - 가변 길이 인코딩 : 인코딩 결과가 1바이트 ~ 4바이트
        - 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다름
