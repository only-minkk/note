컴퓨터 구조

# 목차

- [목차](#목차)
- [1. 컴퓨터 구조 시작하기](#1-컴퓨터-구조-시작하기)
  - [1. 컴퓨터가 이해하는 정보](#1-컴퓨터가-이해하는-정보)
    - [1. 데이터](#1-데이터)
    - [2. 명령어](#2-명령어)
  - [2. 컴퓨터의 네 가지 핵심 부품](#2-컴퓨터의-네-가지-핵심-부품)
    - [1. CPU](#1-cpu)
    - [2. 메모리](#2-메모리)
    - [3. 보조기억장치](#3-보조기억장치)
    - [4. 입출력장치](#4-입출력장치)
    - [5. 메인보드](#5-메인보드)
- [2. 데이터](#2-데이터)
  - [1. 0과 1로 숫자를 표현하는 방법](#1-0과-1로-숫자를-표현하는-방법)
    - [1. 이진법 (binary)](#1-이진법-binary)
    - [2. 십육진법](#2-십육진법)
  - [2. 0과 1로 문자를 표현하는 방법](#2-0과-1로-문자를-표현하는-방법)
    - [1. 아스키 코드 (ASCII)](#1-아스키-코드-ascii)
    - [2. 언어별 인코딩 등장](#2-언어별-인코딩-등장)
- [3. 명령어](#3-명령어)
  - [1. 소스 코드와 명령어](#1-소스-코드와-명령어)
    - [1. 저급 언어](#1-저급-언어)
    - [2. 고급 언어](#2-고급-언어)
    - [3. 모든 언어가 컴파일 언어와 인터프리트 언어로 양분되는 개념은 아니다.](#3-모든-언어가-컴파일-언어와-인터프리트-언어로-양분되는-개념은-아니다)
  - [2. 명령어의 구조](#2-명령어의-구조)
  - [3. (추가) 소스 코드가 명령어가 되기까지](#3-추가-소스-코드가-명령어가-되기까지)
- [4. CPU의 작동 원리](#4-cpu의-작동-원리)
  - [1. ALU와 제어장치](#1-alu와-제어장치)
    - [1. ALU](#1-alu)
    - [2. 제어장치](#2-제어장치)
  - [2. 레지스터](#2-레지스터)
    - [1. 프로그램 카운터](#1-프로그램-카운터)
    - [2. 명령어 레지스터](#2-명령어-레지스터)
    - [3. 메모리 주소 레지스터](#3-메모리-주소-레지스터)
    - [4. 메모리 버퍼 레지스터](#4-메모리-버퍼-레지스터)
    - [5. 플래그 레지스터](#5-플래그-레지스터)
    - [6. 범용 레지스터](#6-범용-레지스터)
    - [7. 스택 포인터](#7-스택-포인터)
    - [8. 베이스 레지스터](#8-베이스-레지스터)
  - [3. 명령어 사이클과 인터럽트](#3-명령어-사이클과-인터럽트)
    - [1. 명령어 사이클](#1-명령어-사이클)
    - [2. 인터럽트](#2-인터럽트)
- [5. CPU의 성능 향상 기법](#5-cpu의-성능-향상-기법)
  - [1. 빠른 CPU를 위한 설계 기법](#1-빠른-cpu를-위한-설계-기법)
    - [1. 코어와 멀티 코어](#1-코어와-멀티-코어)
    - [2. 스레드와 멀티 스레드](#2-스레드와-멀티-스레드)
  - [2. 명령어 병렬 처리 기법](#2-명령어-병렬-처리-기법)
    - [1. 명령어 파이프라인](#1-명령어-파이프라인)
    - [2. 슈퍼스칼라](#2-슈퍼스칼라)
    - [3. 비순차적 명령어 처리](#3-비순차적-명령어-처리)
  - [3. 명령어 집합 구조, CISC와 RISC](#3-명령어-집합-구조-cisc와-risc)
    - [1. 명령어 집합 구조 (ISA || Instruction Set Architecture)](#1-명령어-집합-구조-isa--instruction-set-architecture)
    - [2. CISC(Complex Instruction Set Computer)](#2-cisccomplex-instruction-set-computer)
    - [3. RISC(Reduced Instruction Set Computer)](#3-riscreduced-instruction-set-computer)
- [6. 메모리와 캐시 메모리](#6-메모리와-캐시-메모리)
  - [1. RAM의 특징과 종류](#1-ram의-특징과-종류)
    - [1. DRAM(Dynamic RAM)](#1-dramdynamic-ram)
    - [2. SRAM(Static RAM)](#2-sramstatic-ram)
    - [3. SDRAM (Synchronous DRAM) (SDR SDRAM||Single Data Rate)](#3-sdram-synchronous-dram-sdr-sdramsingle-data-rate)
    - [4. DDR SDRAM (Double Data Rate SDRAM)](#4-ddr-sdram-double-data-rate-sdram)
  - [2. 메모리의 주소 공간](#2-메모리의-주소-공간)
    - [1. 물리 주소](#1-물리-주소)
    - [2. 논리 주소](#2-논리-주소)
    - [3. 물리 주소와 논리 주소의 변환](#3-물리-주소와-논리-주소의-변환)
    - [4. 메모리 보호](#4-메모리-보호)
  - [3. 캐시 메모리](#3-캐시-메모리)
    - [1. 저장 장치 계층 구조 (메모리 계층 구조 | memory hierarchy)](#1-저장-장치-계층-구조-메모리-계층-구조--memory-hierarchy)
    - [2. 캐시메모리](#2-캐시메모리)
    - [3. 캐시 메모리까지 반영한 저장 장치 계층 구조](#3-캐시-메모리까지-반영한-저장-장치-계층-구조)
- [7. 보조기억장치](#7-보조기억장치)
  - [1. 다양한 보조기억장치](#1-다양한-보조기억장치)
    - [1. 하드 디스크](#1-하드-디스크)
    - [2. 플래시 메모리](#2-플래시-메모리)
  - [2. RAID의 정의와 종류](#2-raid의-정의와-종류)
    - [1. RAID의 정의](#1-raid의-정의)
    - [2. RAID의 레벨(종류)](#2-raid의-레벨종류)
- [8. 입출력장치](#8-입출력장치)
  - [1. 장치 컨트롤러와 장치 드라이버](#1-장치-컨트롤러와-장치-드라이버)
    - [1. 장치 컨트롤러](#1-장치-컨트롤러)
    - [2. 장치 컨트롤러의 역할](#2-장치-컨트롤러의-역할)
    - [3. 장치 컨트롤러의 구조](#3-장치-컨트롤러의-구조)
    - [4. 장치 드라이버](#4-장치-드라이버)
  - [2. 다양한 입출력방법](#2-다양한-입출력방법)
    - [1. 프로그램 입출력](#1-프로그램-입출력)
    - [2. 인터럽트 기반 입출력](#2-인터럽트-기반-입출력)
    - [3. DMA 입출력](#3-dma-입출력)
    - [4. 입출력 버스](#4-입출력-버스)
- [9. 운영체제 시작하기](#9-운영체제-시작하기)
  - [1. 운영체제를 알아야 하는 이유](#1-운영체제를-알아야-하는-이유)
    - [1. 운영체제란](#1-운영체제란)
  - [2. 운영체제의 큰 그림](#2-운영체제의-큰-그림)
    - [1. 커널이란?](#1-커널이란)
    - [2. 운영체제의 서비스 종류](#2-운영체제의-서비스-종류)
- [10. 프로세스와 스레드](#10-프로세스와-스레드)
  - [1. 프로세스 개요](#1-프로세스-개요)
    - [1. 프로세스](#1-프로세스)
    - [2. 프로세스 제어 블록](#2-프로세스-제어-블록)
    - [3. 문맥교환](#3-문맥교환)
    - [4. 프로세스의 메모리 영역](#4-프로세스의-메모리-영역)
  - [2. 프로세스 상태와 계층 구조](#2-프로세스-상태와-계층-구조)
    - [1. 프로세스 상태](#1-프로세스-상태)
    - [2. 프로세스 계층 구조](#2-프로세스-계층-구조)
    - [3. 프로세스 생성 기법](#3-프로세스-생성-기법)
  - [3. 스레드](#3-스레드)
    - [1. 프로세스와 스레드](#1-프로세스와-스레드)
    - [2. 멀티 프로세스와 멀티 스레드](#2-멀티-프로세스와-멀티-스레드)
- [11. CPU 스케줄링](#11-cpu-스케줄링)
  - [1. CPU 스케줄링 개요](#1-cpu-스케줄링-개요)
    - [1. 프로세스 우선순위 (priority)](#1-프로세스-우선순위-priority)
    - [2. 스케줄링 큐](#2-스케줄링-큐)
    - [3. 선점형과 비선점형 스케줄링](#3-선점형과-비선점형-스케줄링)
  - [2. CPU 스케줄링 알고리즘](#2-cpu-스케줄링-알고리즘)
- [12. 프로세스 동기화](#12-프로세스-동기화)
  - [1. 동기화란](#1-동기화란)
    - [1. 동기화의 의미](#1-동기화의-의미)
  - [2. 동기화 기법](#2-동기화-기법)
    - [1. 뮤텍스 락](#1-뮤텍스-락)
    - [2. 세마포](#2-세마포)
    - [3. 모니터](#3-모니터)

# 1. 컴퓨터 구조 시작하기

## 1. 컴퓨터가 이해하는 정보

### 1. 데이터

- 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
- 컴퓨터와 주고받는/내부에 저장된 정보를 데이터라 통칭하기도
- 0과 1로 숫자를 표현하는 방법
- 0과 1로 문자를 표현하는 방법

### 2. 명령어

- 컴퓨터는 결국 명령어를 처리하는 기계
- 명령어
  - 컴퓨터를 실질적으로 움직이는 정보
  - 데이터는 명령어를 위한 일종의 재료
- 명령어의 생김새와 동작 방식
- ex) '1'과 '2'를 더해라.
  - '1','2' 는 데이터.
  - '더하라' 는 명령어.
- ex) '안녕하세요'를 출력하라
  - '안녕하세요'는 데이터.
  - '출력하라'는 명령어.

## 2. 컴퓨터의 네 가지 핵심 부품

### 1. CPU

- CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 부품이다. (컴퓨터의 두뇌)
- CPU의 핵심적인 내부 구성 부품 3가지

  - `ALU` : 산술 논리 연산 장치
    - 계산기
  - `제어장치` : 컨트롤 유닛
    - 제어 신호를 내보내고, 명령어를 해석하는 장치
      - 제어 신호 : 컴퓨터 부품들을 관리하고 작동시키기 위한 전기 신호
      - 제어 신호의 종류 대표적인 2가지
        - `메모리 읽기 신호` : CPU가 저장된 값을 읽고 싶을 땐 메모리를 향해 메모리 읽기라는 제어 신호를 보낸다.
        - `메모리 쓰기 신호` : CPU가 메모리에 어떤 값을 저장하고 싶을 땐 메모리를 향해 메모리 쓰기라는 제어 신호를 보낸다.
  - `레지스터` (여러개 존재)
    - CPU 내부의 작은 저장장치

  ```markdown
  메모리 1번지 : 더하라, 3번지와 4번지를
  메모리 2번지 : 저장하라, 연산 결과를
  메모리 3번지 : 120
  메모리 4번지 : 100
  메모리 5,6번지 : 비어있음.

  1. CPU의 제어장치가 메모리 1번지를 향해서 메모리 읽기라고 하는 제어 신호를 내보냄.
     1. 메모리 1번지에 저장되어 있는 명령어를 CPU의 레지스터 즉, CPU의 내부에 있는 작은 저장장치로 갖다 주게 됨.
     2. 레지스터에 저장된 명령어를 제어장치가 해석함.
  2. 제어장치는 '3번지와 4번지에 저장된 데이터가 필요하겠구나' 라고 판단함. (100, 120)
  3. 제어장치는 메모리 읽기 신호를 보내서 필요한 데이터를 한 번 더 갖고 오게 된다.
     1. 3번지, 4번지에 있는 데이터가 레지스터에 저장됨.
  4. 제어장치가 ALU에게 데이터를 더하라고 지시함.
     1. ALU는 데이터를 가지고 더하라는 명령어를 실행한 뒤에 결과값을 레지스터에 담는다. (100 + 120 = 220)
  5. 제어장치는 메모리 2번지를 향해 메모리 읽기 신호를 보낸다.
     1. 메모리 2번지에 저장되어 있는 명령어가 레지스터에 저장됨.
     2. 레지스터에 저장된 명령어를 제어장치가 해석함.
  6. 제어장치는 '계산 결과인 220을 메모리에 저장해야겠구나'라고 판단함.
  7. 제어장치는 쓰기 신호와 함께 결과값을 메모리에 저장하게 된다.
  ```

### 2. 메모리

- 주기억장치 or 메인 메모리
  1.  RAM (이 책에서는 RAM을 지칭)
      - 현재 실행되고 있는 명령어와 데이터가 저장
        - 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다.
        - 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다.
        - 메모리에 저장된 값의 위치는 주소로 알 수 있다.
  2.  ROM

### 3. 보조기억장치

- 보조기억장치가 필요한 이유
  - 메모리는 (보조기억장치에 비해) 비싸다.
  - 메모리는 전원이 꺼지면 저장된 데이터가 날아감(휘발성).
- 메모리는 실행할 정보를 저장, 보조기억장치는 보관할 정보를 저장.

### 4. 입출력장치

- 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품.
  - 모니터, 키보드, 마우스 등.

### 5. 메인보드

- 4가지 핵심부품을 연결할 수 있는 판.
- 메인보드에 연결된 부품들은 버스를 통해 정보를 주고 받는다.
  - 버스는 컴퓨터의 부품끼리 정보를 주고받는 일종의 통로
  - 다양한 종류의 버스가 있음.
  - 중요한 역할을 하는 버스, 가장 중요한 버스(사람에 비유하면 척추), 컴퓨터의 핵심 부품을 연결하는 버스는 `시스템 버스`라고 한다.
    - 시스템 버스의 내부 구성
      - 주소 버스 : 주소를 주고받는 통로
      - 데이터 버스 : 명령어와 데이터를 주고받는 통로
      - 제어 버스 : 제어 신호를 주고받는 통로
    - 메모리 값 읽기
      - 제어장치는 `주소 버스에 읽고자 하는 주소(1번지)를 담고`, `제어 버스에 메모리 읽기 신호를 담아`서 메모리로 보낸다.
      - 메모리는 `[1번지 + 읽기]를 받고 '아 1번지를 읽고 싶구나' 판단.`
      - 메모리는 `데이터 버스에 데이터를 담아`서 레지스터로 보낸다.
    - 메모리 값 쓰기
      - 제어장치는 `주소 버스에 쓰고자 하는 주소(5번지)를 담고`, `제어 버스에 메모리 쓰기 신호을 담고`, `데이터 버스에 220이라는 결과값을 담아`서 메모리로 보낸다.
      - 메모리는 `[5번지 + 쓰기 + 220]을 받고 '아 5번지에 220을 쓰고싶구나' 판단.`
- 각 장치들이 시스템 버스를 통해서 정보를 주고 받는다.

# 2. 데이터

## 1. 0과 1로 숫자를 표현하는 방법

1. 정보 단위

   - 비트 (bit) : 0과 1을 표현하는 가장 작은 정보 단위
     - 1비트로는 0 과 1. 총 두 가지의 정보를 표현할 수 있다.
     - 2비트로는 총 4 가지, 3비트로는 총 8 가지의 정보를 표현할 수 있다.
     - n비트로 2ⁿ가지의 정보 표현 가능
     - 프로그램은 수많은 비트로 이루어져 있음
       ```markdown
       - 1바이트(byte) = 8비트(8bit)
       - 1킬로바이트(1kB) = 1000바이트(1,000byte)
       - 1메가바이트(1MB) = 1000킬로바이트(1,000kB)
       - 1기가바이트(1GB) = 1000메가바이트(1,000MB)
       - 1테라바이트(1TB) = 1000기가바이트(1,000GB)
       ```

2. 워드 (word)

   - CPU가 한 번에 처리할 수 있는 정보의 크기 단위
     - CPU가 한 번에 32비트를 처리할 수 있다면 해당 CPU는 1워드는 32비트이다. 64비트를 처리할 수 있다면 1워드는 64비트이다.
   - 하프 워드 (half word) : 워드의 절반 크기
   - 풀 워드 (full word) : 워드 크기
   - 더블 워드 (double word) : 워드의 두 배 크기

### 1. 이진법 (binary)

- 0과 1로 수를 표현하는 방법
  - 숫자가 1을 넘어가는 시점에 자리올림
  - 우리가 일상적으로 십진법(decimal)을 사용함
  - 이진수 8 표기 -> 1000₍₂₎ <수학적 표기 방식> or 0b1000 <코드상 표기 방식>
- 0과 1로 음수 표현하기 : 2의 보수
  - 어떤 수를 그보다 큰 2ⁿ에서 뺀 값
    ```
    11₍₂₎보다 큰 2ⁿ = 100₍₂₎
    100₍₂₎ - 11₍₂₎ = 01₍₂₎
    11₍₂₎을 음수로 표현한 값 = 01₍₂₎
    ```
  - 모든 0과 1을 뒤집고 1을 더한 값 (더 쉬운 방법)
    ```
    11₍₂₎ -> 모든 0과 1을 뒤집기 -> 00₍₂₎
    00₍₂₎ -> 1을 더함 -> 01₍₂₎
    11₍₂₎을 음수로 표현한 값 = 01₍₂₎
    ```
  - 음수 0101₍₂₎ 과 십진수 5를 표현한 0101₍₂₎ 구분
    - 플래그(flag) 레지스터라는 CPU 내부에 있는 특별한 레지스터가 존재.
    - 플래그 레지스터가 COU내부에서 음수인지 양수인지 표기해줌.

### 2. 십육진법

- 이진법으로는 숫자의 길이가 너무 길어진다.
  - 십진수 32 === 100000₍₂₎
- 컴퓨터의 데이터를 표현할 때 십육진법도 많이 사용
  - 수가 15를 넘어가는 시점에 자리올림

```
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ,,
0 1 2 3 4 5 6 7 8 9 A  B  C  D  E  F  10 11 12 ,,
```

- 십육진수 15 표기 -> 15₍₁₆₎ <수학적 표기 방식> or 0x15 <코드상 표기 방식>

## 2. 0과 1로 문자를 표현하는 방법

- 문자집합 (character set)
  - 컴퓨터가 이해할 수 있는 문자의 모음
- 인코딩 (encoding) (문자를 표현하는 방식의 국한해서 정의)
  - 코드화 하는 과정
  - 문자를 0과 1로 이루어진 문자 코드로 변환하는 과정
- 디코딩 (decoding) (문자를 표현하는 방식의 국한해서 정의)
  - 코드를 해석하는 과정
  - 0과 1로 표현된 문자 코드로 문자로 변환하는 과정

### 1. 아스키 코드 (ASCII)

- 초창기 문자 집합 중 하나
- 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
- 7비트로 하나의 문자 표현
  - 실제 사용하는 8비트중 1비트는 오류 검출을 위해 사용되는 패리티 비트(parity bit)
  - 2⁷개의 문자 즉 128개 정도의 문자를 ASCII 코드로 표현할 수 있다.
- 간단한 인코딩
- BUT 한글을 포함한 다른 언어 문자, 다양한 특수 문자 표현 불가.
  - 아스키 코드는 7비트로 하나의 문자를 표현하기에 128개보다 많은 문자를 표현할 수 없다.
  - 8비트 확장 아스키 (extended ASCII)의 등장 -> 여전히 부족

### 2. 언어별 인코딩 등장

- 한글을 위한 인코딩이 필요
  - 한글의 특징
    - 알파벳을 이어 쓰면 단어가 되는 영어에 반해 초성, 중성, 종성의 조합으로 이루어진 한글
  - 완성형 인코딩 방식과 조합형 인코딩 방식이 존재
    - 완성형 인코딩 방식
      - 음절 하나하나에 코드를 부여
    - 조합형 인코딩 방식
      - 자음 모음 각각에 고유한 코드를 부여

1.  ECU-KR 방식
    - KS X 1001 KS X 1003 문자집합 기반의 한글 인코딩 방식
    - 완성형 인코딩
    - 글자 하나 하나에 2바이트 크기의 코드 부여
      - 2바이트 == 16비트 == 4자리 십육진수로 표현
    - 2300여개의 한글 표현 가능, 여전히 모든 한글을 표현하기에는 부족한 수. 쀏, 뙠, 휔 같은 한글 표현 불가
    - 이렇게 언어별 인코딩을 국가마다 하게 되면 다국어를 지원하는 프로그램을 개발할 때엔 언어별 인코딩 방식을 모두 이해해야 한다.
      - 모든 언어, 특수문자까지 통일된 문자 집합을 사용하면 어떨까? 통일된 문자 집합 & 인코딩 방식이 있다면 어떨까?
2.  유니코드 문자 집합과 utf-8 인코딩 방식
    - 유니코드
      - 통일된 문자 집합
      - 한글, 영어, 화살표와 같은 특수 문자, 이모티콘까지 표현 가능
      - 현대 문자 표현에 있어 매우 중요한 위치
    - 유니코드의 인코딩 방식
      - utf-8, utf-16, utf-32 ,,,
    - utf-8 인코딩
      - UTF (Unicode Transformation Format) == 유니코드 인코딩 방법
      - 가변 길이 인코딩 : 인코딩 결과가 1바이트 ~ 4바이트
      - 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다름

# 3. 명령어

## 1. 소스 코드와 명령어

- 고급언어 --- 변환 ---> 저급언어
  - 고급언어
    - 프로그래밍 언어
    - 개발자가 읽고 쓰기 편하게 만들어진 언어.
  - 저급 언어
    - 컴퓨터가 이해하고 실행하는 언어.

### 1. 저급 언어

1.  기계어
    - 0과 1로 이루어진 명령어로 구성된 저급 언어
    - 16진수로 표현되기도 함.
2.  어셈블리어
    - 0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어

### 2. 고급 언어

- 고급 언어가 저급 언어로 변환되는 방식에는 2가지가 있다.

1.  컴파일 방식
    - 컴파일 언어로 작성된 소스 코드는 컴파일러에 의해 저급 언어로 변환되고(이 과정을 컴파일이라고 한다.), 컴파일 결과로 저급 언어인 목적 코드가 생성된다.
    - 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않음
2.  인터프리트 방식
    - 인터프리터에 의해 한 줄씩 실행
    - 소스 코드 전체가 저급 언어로 변환되기까지 기다릴 필요 없음
    - 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행

- 컴파일 과정

  | c언어          | 저급언어                                                                                                |
  | -------------- | ------------------------------------------------------------------------------------------------------- |
  | int main( ) {  | push rbp<br>mov rbp, rsp                                                                                |
  | int a = 1;     | mov rbp, rsp                                                                                            |
  | int b = 2;     | mov DWORD PTR [rbp-8], 2                                                                                |
  | int c = a + b; | mov edx, DWORD PTR [rbp-4]<br>mov eax, DWORD PTR [rbp-8]<br>add eax, edx<br>mov DWORD PTR [rbp-12], eax |
  | return 0;      | mov eax, 0                                                                                              |
  | }              | pop rbp<br>ret                                                                                          |

  - cpu의 종류와 컴파일러의 종류에 따라 변환된 저급 언어의 모습은 달라진다.
    - 현재 컴파일된 저급언어는 'x86-64 gcc 13.2'로 변환이 된 상태이다.
      - 'x86-64'는 CPU 종류
      - 'gcc 13.2'는 컴파일러의 종류이다.

### 3. 모든 언어가 컴파일 언어와 인터프리트 언어로 양분되는 개념은 아니다.

- 컴파일 방식과 인터프리트 방식이 있는데 이 두 가지 방식은 고급 언어가 저급 언어로 변환되는 아주 대표적인 방식 중에 하나다 정도로 이해.

## 2. 명령어의 구조

- 명령어의 구조
  - 수행할 연산 | 연산에 사용될 데이터 혹은 데이터가 저장된 주소
    - ex) 더해라 | 100과 | 120을
    - ex) 빼라 | 메로리 32번지 안의 값과 | 메모리 33번지 안의 값을
    - ex) 저장해라 | 10을 | 메모리 128번지에
  - 명령어는 연산 코드와 오퍼랜드로 구성된다.

1. 연산코드

   - 연산 코드의 종류 & 생김새는 CPU 마다 다름.

   1. 데이터 전송
      - 대표적인 연산 코드의 종류
        - (암기 필요 X, 유형을 익히자.)
        - MOVE : 데이터를 옮겨라
        - STORE : 메모리에 저장하라
        - LOAD (FETCH) : 메모리에서 CPU로 데이터를 가져와라
        - PUSH : 스택에 데이터를 저장하라
        - POP : 스택의 최상단 데이터를 가져와라
          - 스택은 아래가 막혀있는 통과 같은 자료구조
            - 쌓이는 스택의 순서와 꺼내는 스택의 순서가 반대.
            - 제일 나중에 들어간 스택이 먼저 나오게 되는 자료구조
              - '라스트 인 퍼스트 아웃'
              - 줄여서 '리포'라고도 한다.
          - 큐는 양쪽 끝이 뚫려있는 호스와 같은 구조.
            - 먼저 들어간 큐가 먼저 나옴
              - '퍼스트 인 퍼스트 아웃'
              - 줄여서 '피포'라고도 한다.
   2. 산술/논리 연산
      - ADD / SUBTRACT / MULTIPLY / DIVIDE
        - 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
      - INCREMENT / DECREMENT
        - 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
      - AND / OR / NOT
        - AND / OR / NOT 연산을 수행하라
      - COMPARE
        - 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
   3. 제어 흐름 변경
      - JUMP
        - 특정 주소로 실행 순서를 옮겨라
      - CONDITIONAL JUMP
        - 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
      - HALT
        - 프로그램의 실행을 멈춰라
      - CALL
        - 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
      - RETURN
        - CALL을 호출할 때 저장했던 주소로 돌아가라
   4. 입출력 제어
      - READ (INPUT)
        - 특정 입출력 장치로부터 데이터를 읽어라
      - WRITE (OUTPUT)
        - 특정 입출력 장치로 데이터를 써라
      - START IO
        - 입출력 장치를 시작하라
      - TEST IO
        - 입출력 장치의 상태를 확인하라

2. 오퍼랜드

   - 연산에 사용될 테이터 or 연산에 사용될 데이터가 저장된 위치
     - 하지만 데이터 보다 연산에 사용될 데이터의 주소가 더 자주 저장되게 된다.
     - 그렇기 때문에 오퍼랜드 필드를 주소 필드라고 부르기도 함.
   - 오퍼랜드가 있거나 없는 경우도 있다.
     - 오퍼랜드가 없는 경우 (0-주소 명령어)
     - 한 개인 경우 (1-주소 명령어)
     - 두 개 or 세 개인 경우 (2-주소 or 3-주소 명령어)

   ```markdown
   주소를 넣는 경우가 많아 주소필드라고도 불리는 오퍼랜드 필드에 왜 데이터를 넣지 않고 주소를 넣느냐?

   - 명령어 내에서 표현할 수 있는 데이터의 크기가 제한되기 때문
     - 16비트의 명령어 = 4비트의 연샅코드 + 2개의 오퍼랜드 (각 6비트)
     - 이런 경우 하나의 오퍼랜드에서 표현할 수 있는 데이터의 크기는 2⁶이다.
     - 오퍼랜드의 개수가 늘어날 수록 표현할 수 있는 데이터의 크기는 줄어든다.
   - 주소를 명시할 경우 주소의 크기 만큼의 데이터를 담는 것이나 마찬가지. (메모리의 주소 or 레지스터의 주소)
     - 10번지의 담을 수 있는 데이터의 크기가 16비트이고, 오퍼랜드의 크기는 4비트라고 했을 때, 10번지라는 주소를 담는다면.
     - 16비트의 값을 오퍼랜드 필드로 표현할 수 있는 것이나 마찬가지
   ```

3. 명령어 주소 지정 방식

   - 유효 주소 (effective address)
     - 연산에 사용할 데이터가 저장된 위치
   - 명령어 주소 지정 방식 (addressing modes)
     - 연산에 사용할 데이터가 저장된 위치를 찾는 방법
     - 유효 주소를 찾는 방법
     - 다양한 명령어 주소 지정 방식들 (cpu 마다 차이가 있음)

4. 명령어 주소 지정 방식 종류
   - 즉시 주소 지정 방식 (immediate addressing mode)
     - 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
     - 가장 간단한 형태의 주소 지정 방식
     - 연산에 사용할 데이터의 크기가 작아질 수 있다.
     - 다른 주소로 접근하는 과정이 없기 때문에 빠름.
   - 직접 주소 지정 방식 (direct addressing mode)
     - 오퍼랜드 필드에 유효 주소를 직접적으로 명시
     - 유효 주소를 표현할 수 있는 크기가 줄어듦.
   - 간접 주소 지정 방식 (indirect addressing mode)
     - 오퍼랜드 필드에 유효 주소의 주소를 명시
       - 유효 주소가 담겨있는 주소를 명시하면 유효 주소를 충분히 표현 할 수 있게 됨.
         - 오퍼랜드에 담을 수 있는 크기보다 메모리에 담을 수 있는 크기가 더 크기 때문에 더 큰 유효 주소를 표현할 수 있다.
     - 앞선 주소 지정 방식들에 비해 속도가 느림
       - 메모리를 여러번 접근해야 함
   - 레지스터 주소 지정 방식 (register addressing mode)
     - 연산에 사용할 데이터가 저장된 레지스터 명시
     - 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름
   - 레지스터 간접 주소 지정 방식 (register indirect addressing mode)
     - 연산에 사용할 데이터를 메모리에 저장
     - 그 유효 주소를 레지스터에 저장
     - 유효 주소가 저장되어있는 레지스터의 주소를 오퍼랜드 필드에 명시
   - 스택 주소 지정 방식 : 스택 포인터에 따라 데이터를 읽는 방식
   - 변위 주소 지정 방식
     1. 상대 주소 지정 방식
        - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
     2. 베이스 레지스터 주소 지정 방식
        - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식

## 3. (추가) 소스 코드가 명령어가 되기까지

    C 언어 컴파일 과정

    소스코드 -> [전처리기(preprocessor)] -> [컴파일러(compiler)] -> [어셈블러(assembler)] -> [링커(linker)] -> 실행파일

    test.c -> 전처리 -> 컴파일 -> 어셈블 -> 링킹 -> test.exe

1.  전처리 과정 (preprocessing)

    - 본격적으로 컴파일하기 전 준비작업
    - 외부에 선언된 다양한 소스 코드, 라이브러리 포함 (e.g. #include)
    - 프로그래밍의 편의를 위해 작성된 매크로 변환 (e.g. #define)
    - 컴파일할 영역 명시 (e.g. #if, #ifdef ,,,)

    ````markdown
    예를들어

        ```c++
        #include <stdio.h>

        int main() {
            printf("hello, world!\n");
            return 0;
        }
        ```

    위와 같은 소스 코드가 있다면 'stdio.h'라는 일종의 소스코드의
    내용을 해당 소스코드로 가져오는, 포함시키는 과정이 전처리 과정의
    일부이다. 컴파일 하기위한 준비.
    ````

2.  컴파일 과정 (compiling)

    - 전처리가 완료 되어도 여전히 소스 코드.
    - 전처리가 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환
    - 어셈블리 언어는 CPU마다 컴파일러마다 형태가 다를 수 있다.

3.  어셈블 과정 (assembling)

    - 어셈블리어를 기계어로 변환
    - 목적 코드(object file)를 포함하는 목적 파일이 된다.

          목적 파일 vs 실행 파일

          목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일
          But, 목적 파일과 실행 파일은 다르다.
          목적 파일은 링킹(linking)을 거친 이후에야 실행 파일이 된다.

4.  링킹 과정 (linking)
    - 각기 다른 목적 코드를 하나의 실행 파일로 묶어주는 작업 즉, 연결 시켜주는 작업이 링킹
    - 링킹을 거친 후에 실행 파일이 된다.

# 4. CPU의 작동 원리

## 1. ALU와 제어장치

- CPU는 ALU, 제어장치, 레지스터 등으로 구성.
- ALU는 계산하는 장치
- 제어장치는 제어 신호를 발생시키고 명령어를 해석하는 장치

### 1. ALU

- 받아들이는 정보
  - 계산을 하기 위해 피연산자와 수행할 연산이 필요
  - 레지스터로부터 피연산자, 제어장치로부터 제어신호를 받아들인다.
- 내보내는 정보
  - 계산을 완료하고 결괏값을 내보낸다.
  - 결괏값을 레지스터, 플래그를 플래그 레지스터로 보내준다.
    - CPU가 메모리에 접근하는 속도보다 레지스터에 접근하는 속도가 빠르기 때문에 레지스터에 담는다.
    - 플래그는 연산 결과에 대한 부가정보이다.
      - 부호 플래그 : 연산한 결과의 부호(1:-,0:+)
      - 제로 플래그 : 연산 결과가 0인지의 여부(1:0,0:0x)
      - 캐리 플래그 : 올림수나 빌림수의 발생 여부(1:발생,0:발생x)
      - 오버플로우 플래그 : 오버플로우 여부(1:발생,0:발생x)
      - 인터럽트 플래그 : 인터럽트 가능 여부(1:가능,0:불가능)
      - 슈퍼바이저 플래그 : 커널 모드로 실행중인지, 사용자 모드로 실행중인지(1:커널,0:사용자)

### 2. 제어장치

- 받아들이는 정보
  - 클럭 신호
    - 컴퓨터의 모든 부품을 일사분란하게 움직일 수 있게 하는 시간 단위
  - 명령어 레지스터로부터 해석할 명령어를 받아들인다.
  - 플래그 레지스터로부터 플래그를 받아들인다.
  - 제어버스를 통해 CPU외부로부터 발생한 제어 신호를 받아들인다.
- 내보내는 정보
  - ALU, 레지스터로 제어신호를 보낸다.
    - 레지스터 : 레지스터간에 어떤 정보를 이동해라, 어떤 값을 저장해라, 어떤 행동을 해라 등과 같은 레지스터를 움직이게 하는 제어신호를 보낸다.
    - ALU : 수행할 연산을 지시하는 제어신호를 보낸다.
  - 제어버스를 통해 CPU 외부(메모리,입출력장치)로 제어 신호를 보낸다.
    - 메모리 : 메모리를 읽어라, 써라같은 제어 신호를 보낸다.
    - 입출력장치 : 읽어라, 써라, 테스트해라 같은 제어 신호를 보낸다.

## 2. 레지스터

- CPU 내부의 작은 임시저장장치
- 프로그램 속 명령어 & 데이터는 실행 전,후로 레지스터에 저장
- CPU 내부에는 다양한 레지스터들이 존재. 각기 다른 역할.
  - CPU마다 레지스터의 개수, 이름 등이 다른 경우가 있다.

### 1. 프로그램 카운터

- 메모리에서 가져올 명령어의 주소(메모리에서 읽어 들일 명령어의 주소)
  - Instruction Pointer(명령어 포인터)라고 부르는 CPU도 존재.

### 2. 명령어 레지스터

- 해석할 명령어 (방금 메모리에서 읽어 들인 명령어)

### 3. 메모리 주소 레지스터

- 메모리의 주소
  - CPU가 읽어 들이고자 하는 주소를 주소 버스로 보낼 때 거치는 레지스터

### 4. 메모리 버퍼 레지스터

- 메모리와 주고받을 값 (데이터와 명령어)

  - CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터

  ```markdown
  - 이해하기 쉽게 프로그램을 이루는 명령어들이 각각 하나의 메모리 번지를 차지하고 있다고 가정
  - 메모리 1000번지 ~ 1500번지까지 CPU가 실행하고자 하는 프로그램이 저장.
  - 1000번지부터 시작한다고 가정

  1. 프로그램 카운터에 1000번지가 저장된다.

  - 메모리에서 가져올 명령어의 주소가 저장되기 때문.
  - CPU는 1000번지를 실행할 예정이기 때문에 1000번지라는 주소가 프로그램 카운터에 저장.

  2. 메모리 주소 레지스터에 1000번지가 담긴다.

  - CPU는 메모리의 1000번지로부터 명령어를 가져오려한다.
  - 주소버스를 통해 읽고자 하는 주소를 메모리로 보내주어야한다.
  - 그때 메모리 주소 레지스터를 거치기 때문에 메모리 주소 레지스터에 주소가 복사된다.

  3. CPU는 메모리 주소 레지스터를 거쳐서 주소 버스를 통해 메모리 주소를, 제어 버스를 통해 제어신호(메모리 읽기)를 보낸다.
  4. 해당 주소로 제어 신호를 받은 메모리는 저장된 값을 데이터 버스를 통해 메모리 버퍼 레지스터에 전달해주게 된다.
  5. 프로그램 카운터는 1이 증가된다.

  - 다음으로 실행할 주소가 저장.

  6. 메모리 버퍼 레지스터에 담긴 명령어를 해석하기 위해 해당 명령어가 명령어 레지스터에 담긴다.
  ```

  ```markdown
  프로그램 카운터가 1씩 증가하는 것이 프로그램을 순차적으로 실행할 수 있는 원리가 된다.

  프로그램의 순차적인 실행 흐름이 끊기는 경우

  - 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
    - (e.g. JUMP, CONDITIONAL JUMP, CALL, RET)
  - 인터럽트 발생 시
  - ETC...
  ```

### 5. 플래그 레지스터

- 연산 결과 또는 CPU 상태에 대한 부가적인 정보

### 6. 범용 레지스터

- 다양하고 일반적인 상황에서 자유롭게 사용
- 보통 여러 개 존재.

### 7. 스택 포인터

- 스택의 꼭대기를 가리키는 레지스터 (스택이 어디까지 차 있는지에 대한 표시)
- 특정 레지스터를 이용한 주소 지정 방식에 사용됨.
  - 스택 주소 지정 방식
    - 스택과 스택 포인터를 이용한 주소 지정 방식
    - 메모리 안에 스택처럼 쓸 수 있는 미리 지정된 구역이 존재 (스택 영역)

### 8. 베이스 레지스터

- 기준 주소 저장
- 특정 레지스터를 이용한 주소 지정 방식에 사용됨.
  - 변위 주소 지정 방식
    - 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는다.
    - 보통의 명령어 구조 : 연산코드 , 오퍼랜드로 구성
    - 변위 주소 지정 방식의 명령어의 구조는 다음 꼴을 띄고 있다.
      - 연산코드 + 레지스터(어떤 레지스터와 더할지) + 오퍼랜드(변위 값)
      - 레지스터의 값과 오퍼랜드에 담긴 변위값을 더한 값이 유효 주소이다.
    - 변위 주소 지정 방식은 2가지가 있다. (CPU마다 다를 수 있음)
      1.  상대 주소 지정 방식
          - 오퍼랜드 필드 안에 있는 값과 프로그램 카운터에 있는 값을 더해서 유효주소를 얻는 방식
          - 처음으로 실행할 메모리의 주소가 담긴 프로그램 카운터에서 오퍼랜드 필드에 담긴 변위(+,-)를 더한 값의 주소가 유효주소
      2.  베이스 레지스터 주소 지정 방식
          - 오퍼랜드 필드 안에 있는 값과 베이스 레지스터에 있는 값을 더해서 유효주소를 얻는 방식
          - 베이스 레지스터에는 기준 주소가 담긴다.

## 3. 명령어 사이클과 인터럽트

- CPU는 메모리로부터 명령어나 데이터들을 갖고 와서 실행한다. 필요하다면 값을 저장할 수도 있다.
- 이러한 과정은 일정한 패턴(흐름,주기)을 가지고 있다.
  - 그것을 명령어 사이클이라고 부른다.
- CPU는 명령어 사이클에 따라 처리를 하는데 간혹 그 정해진 흐름을 방해하는 신호가 CPU한테 올 수 있다.
  - 정해진 흐름을 끊는 신호를 인터럽트라고 부른다.

### 1. 명령어 사이클

    - CPU는 프로그램 속의 명령어들을 일정한 주기로 반복하며 실행을 한다.
    - 이러한 주기를 명령어 사이클이라고 함.
    - 인출 사이클
      - 인출 주기
        - 인출 : CPU가 메모리 안에 있는 어떤 프로그램을 실행하기 위해서 메모리에 저장된 값을 CPU 내부로 갖고 오는 작업
    - 실행 사이클
      - 실행 주기
        - 가지고 온 값을 실행하는 주기
    - 일반적으로 CPU는 인출, 실행 사이클이 반복되며 실행된다.
    - 하지만 인출을 했지만 바로 실행할 수 없는 경우도 존재.
      - 간접 주소 지정 방식과 같은 경우.
        - 간접 주소가 10이라면 메모리 10번지에 유효 주소가 담겨있다.
          - 10번지로 가서 유효주소를 가져오고 다시 해당 주소로 접근해야함.
    - 그렇기때문에 일반적인 인출,실행 사이클을 반복하다가 메모리 접근이 더 필요한 경우 간접사이클에 돌입하게 된다.
    - 명령어 사이클은 인출, 실행, 간접, 인터럽트 사이클로 구성되어 있다.

### 2. 인터럽트

    - 인터럽트 (interrupt) : 방해하다, 중단시키다.
    - CPU가 꼭 주목해야 할 때, CPU가 얼른 처리해야 할 다른 작업이 생겼을 때, 발생.
    - 인터럽드 종류

      1.  동기 인터럽트 (예외)
          - CPU가 예기치 못한 상황을 접했을 때 발생
          - 폴트, 트랩, 중단, 소프트웨어 인터럽트 이 4가지 종류가 있다.
      2.  비동기 인터럽트 (하드웨어 인터럽트)

          - 주로 입출력장치에 의해 발생 (알림이나 키보드, 마우스 같은 것들의 클릭)
          - 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트 사용
          - 입출력장치는 CPU에 비해 느리다.
          - 인터럽트가 있다면 입출력 작업 동안 CPU는 다른 일을 할 수 있다.
            - CPU가 계속해서 입출력 작업이 완료되었는지 주기적으로 확인하면서 기다릴 필요가 없음
          - 하드웨어 인터럽트의 처리 순서

            - 인터럽트의 종류에 상관없이 처리 순서는 대동소이함.

              1.  입출력 장치는 CPU에 `인터럽트 요청 신호`를 보낸다.
              2.  CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인함.
              3.  CPU는 인터럽트 요청을 확인하고 `인터럽트 플래그`를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인함.
                  - 인터럽트 플래그는 플래그 레지스터에 있다.
                  - 인터럽트 플래그 : 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
              4.  인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업.
              5.  CPU는 `인터럽트 벡터`를 참조하여 `인터럽트 서비스 루틴`을 실행
                  - 인터럽트 벡터 : 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
                  - 인터럽트 서비스 루틴 : 인터럽트를 처리하는 프로그램
              6.  인터럽트 서비스 루틴 실행이 끝나면 (4)에서 백업해 둔 작업을 복구하여 실행 재개.

                       - 인터럽트 요청 신호 : 입출력장치 같은 주체들이 CPU에게 끼어들어도 되는지 요청을 보내는 신호.
                       - CPU가 인터럽트 요청 신호를 받아들였으면 실행사이클이 끝나고 항상 플래그 레지스터 속에 인터럽트 플래그를 확인한다.
                         - 인터럽트 요청을 받아들일 수 있다면 실행하고 받아들일 수 없다면 실행하지 않는다.
                         - 모든 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다. 하드웨어 고장, 정전 등 매우 긴급하게 처리를 해야만하는 인터럽트들도 존재.
                         - 이렇게 막을 수 없는 인터럽트를 NMI(Non-Maskable-Interrupt)라고 한다.
                       - CPU가 인터럽트를 받아들이기로 했다면 인터럽트 서비스 루틴 실행
                         - 인터럽트 서비스 루틴이란,
                           - 인터럽트가 발생했을 때 해당 인터럽트를 처리하기 위한 프로그램
                         - 인터럽트 서비스 루틴 또한 프로그램이기에 메모리에 각기 다른 루틴들이 저장되어있다.
                       - 인터럽트 벡터 : 각각의 인터럽트를 구분하기 위한 정보
                         - 인터럽트마다 고유한 인터럽트 서비스 루틴의 시작 주소를 가지고 있다.
                         - 인터럽트를 보내는 주체는 인터럽트 요청 신호와 함께 데이터 버스를 통해 인터럽트 벡터도 함께 보낸다.
                       - 인터럽트를 받아들이기 전 레지스터에 저장되어있는 작업들을 스택에 백업해 두게 된다.
                         - 그 후에 인터럽트 서비스 루틴을 실행하기 위한 정보들이 레지스터에 담긴다.
                         - 인터럽트 서비스 루틴이 실행하고 나서 스택에 있는 백업 내용을 복구한다.

# 5. CPU의 성능 향상 기법

## 1. 빠른 CPU를 위한 설계 기법

> CPU의 속도를 빠르게 하려면?

- CPU 특징

  1. 컴퓨터 부품들은 클럭 신호에 맞춰 일사분란하게 움직인다.
  2. CPU는 '명령어 사이클'이라는 정해진 흐름에 맞춰 명령어들을 실행한다.

  그렇다면 클럭 신호가 삐르게 반복되면 컴퓨터 부품이 그만큼 빠른 박자에 맞춰 움직이나?
  꼭 그렇진 않지만 일반적으로 YES
  그렇기에 클럭속도는 CPU의 속도 단위로 간주되기도 함.

- 클럭 속도

  - 클럭 속도 : 헤르츠(Hz) 단위로 측정
  - 헤르츠(Hz) : 1초에 클럭이 반복되는 횟수
    - 클럭이 1초에 100번 반복하면 100Hz
  - CPU의 Max : 4.9GHz, Base : 22.5GHz 라면
    - 클럭이 기본적으로 1초에 25억번 순간적으로 최대 49억 반복
    - CPU는 상황에따라 유동적으로 속도를 조절

  그렇다면 클럭 속도를 마냥 높이면 좋다?

  NO!

  필요 이상으로 클럭을 높이면 발열이 심해진다.

- 클럭 속도 이외에 CPU의 속도를 늘리는 방법은?
  - 코어 수를 늘린다. (듀얼 코어, 멀티 코어 ···)
  - 스레드 수를 늘린다. (멀티 스레드 ···)

### 1. 코어와 멀티 코어

- 코어(Core) 란?
  - 현대적인 관점에서 CPU라는 용어를 재해석 해야 함.
  - CPU = '명령어를 실행하는 부품' <- 전통적으로 '명령어를 실행하는 부품'은 원칙적으로 하나만 존재
  - 하지만 오늘날 CPU에는 '명령어를 실행하는 부품'이 여러 개 존재.
  - '명령어를 실행하는 부품'을 코어라는 용어로 사용
- 멀티코어 프로세서란?

  - 여러 개의 코어를 포함하고 있는 CPU를 말한다.

        그렇다면 코어를 늘리면 연산 속도도 비례해서 빨라지나?

                            NO!!

        코어마다 처리할 연산이 적절할게 분배되지 않는다면
        꼭 코어수에 비례해서 연산속도가 빨라지는 것은 아니다.
        (e.g.조별과제)
        명령어를 각각의 코어에 얼마나 적절하게 분배하느냐가 중요!

### 2. 스레드와 멀티 스레드

- 스레드
  - 실행 흐름의 단위
  1.  소프트웨어적 스레드
  - 스레드 : 하나의 프로그램에서 독립적으로 실행되는 단위
    - 하나의 스레드로 실행된다?
      - 한 프로그램에서 하나의 실행 흐름만 가지고 순차적으로 실행되는 구조를 의미
    - 멀티 스레드로 실행된다?
      - 한 프로그램에서 동시에 두 개의 영역이 실행된다는 의미
      - e.g. 워드 프로세서
        - 입력과 동시에 내용을 화면에 출력
        - 동시에 맞춤법 검사
  - 하드웨어 스레드가 하나여도 여러개의 소프트웨어적인 스레드를 만들 수 있다.
    - 1코어 1스레드 CPU도 여러 개의 소프트웨어적인 스레드를 만들 수 있다.
    - CPU는 내부적으로 여러 개의 프로그램이나 스레드를 실행할 때 엄청 빠른 속도로 번갈아가며 실행되기 때문에 동시에 실행되는 것처럼 느껴짐.
  2.  하드웨어적 스레드 (논리 프로세서)
      - 스레드 : 하나의 코어가 동시에 처리하는 명령어 단위
        - 1개의 코어 1개의 명령어를 처리한다면 -> 1코어 1스레드
        - 2개의 코어, 각각 2개씩의 명령어를 처리한다면 -> 2코어 4스레드 (전체적으로는 동시에 명령어 4개가 처리)
      - 멀티스테드 프로세서 or 멀티스레드 CPU
        - 하나의 코어가 여러 개의 명령어를 동시에 처리할 수 있는 프로세서.
      - e.g. 인텔의 i7 8코어 16스레드 cpu
        - 코어가 8개, 각각 명령어 2개씩 처리할 수 있다는 의미.
        - '하이퍼스레딩'은 intel사의 멀티스레드 기술을 지칭한다는 것 정도로 생각하자.
  - 멀티스레드 프로세서의 핵심은 레지스터
    - 하나의 코어가 여러개의 레지스터 세트를 갖고 있다면 멀티스레드 프로세서를 설계할 수 있다.

## 2. 명령어 병렬 처리 기법

### 1. 명령어 파이프라인

- 명령어가 처리되는 과정
- (전공서에 따라 [인출->실행] or [해석->실행->접근->저장]으로 나누기도 함.)
- 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행한다.
- 명령어 파이프라이닝 : 동시에 여러 개의 명령어를 겹쳐 실행하는 기법

1.  명령어 인출(Instruction Fetch)
2.  명령어 해석(Instruction Decode)
3.  명령어 실행(Execute Instruction)
4.  결과 저장(Write Back)

- 파이프라인 위험
  - 명령어 파이프라인이 성능 향상에 실패하는 경우
  1. 데이터 위험
  - 명령어 간의 의존성에 의해 야기
    - 모든 명령어를 동시에 처리할 수는 없다.
    - 이전 명령어를 끝까지 실행해야만 실행할 수 있는 경우
  2. 제어 위험
  - 프로그램 카운터의 갑작스러운 변화
    - CPU가 실행하고자 하는 메모리의 주소 번지가 갑작스럽게 다른 특정 메모리 주소 번지로 실행의 흐름을 바꾸게 되는 명령어가 실행됐을 때
      - e.g. 점프, 콜, 인터럽트 등
    - 프로그램 카운터가 변경되기 전에 다음 명령어를 인출, 해석 하고 있던 과정들이 무쓸모가 됨. (파이프라인 성능 저하)
  - 제어 위험을 방지하기 위해서 미리 예측하는 기술 존재
    - 분기 예측(branch prediction)
  3. 구조 위험
  - 서로 다른 명령어가 같은 CPU 부품(ALU,레지스터)를 쓰려고 할 때

### 2. 슈퍼스칼라

    - CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조

           이론적으로 파이프라인 개수에 비례하여 처리 속도 증가
           But 파이프라인 위험도의 증가로 인해
           파이프라인 개수에 비례하여 처리 속도가 증가하진 않는다.

### 3. 비순차적 명령어 처리

- 비순차적 명령어 처리 기법 (out of order execution || OOOE)

  - 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 명령어 병렬 처리 기법

        e.g.
        1,2,3,4,5번의 명령어를 실행해야함
        3번 명령어는 1번과 2번이 완료되어야 실행할 수 있다면 데이터 위험이 발생한다.
        3번 명령어 실행을 5번 뒤로 넘긴다면 파이프라인 위험 없이 순차적인 명령어 실행을 할 수 있다.

  - 의존성이 없는 명령어의 순서를 바꾸는 것 만으로 파이프라이닝의 중단을 방지할 수 있다.
    - 순서를 바꿔도 전체 프로그램의 실행 결과, 실행 흐름에 영향이 없는 경우에만 순서를 바꾼다.

## 3. 명령어 집합 구조, CISC와 RISC

    명령어가 어떻게 생겨야 명령어 파이프라이닝에 유리할까?
    CPU는 명령어를 실행한다.
    세상 모든 CPU가 똑같이 생긴 명령어를 실행할까?

            NO!!

    명령어의 세세한 생김새, 연산, 주소 지정 방식 등은 CPU마다 다르다.

### 1. 명령어 집합 구조 (ISA || Instruction Set Architecture)

- CPU가 이해할 수 있는 명령어들의 모음
- CPU의 언어
- 명령어가 달라지면 명령어 해석 방식, 레지스터 종류, 개수 등등 여러가지가 바뀐다.
- 명령어 집합에 따라서 CPU의 구조, 나아가서 컴퓨터의 구조까지도 결정이 되기 때문에 명령어 집합 구조라고 불린다.
- CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이다라는 관점이 존재.

### 2. CISC(Complex Instruction Set Computer)

- 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
  - x86,x86-64는 CISC 기반 명령어 집합 구조
  - 복잡하고 다양한 명령어 활용
  - 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용.
  - 다양하고 강력한 명령어를 활용
  - 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다.
- 단점
  - 메모리를 최대한 아끼며 개발해야 했던 시절에 인기가 높았음.
  - 명령어 파이프라이닝이 불리하다는 치명적인 단점 존재.
    - 명령어가 워낙 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않음
    - 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기 필요

### 3. RISC(Reduced Instruction Set Computer)

- 명령어의 종류가 적고, 짧고 규격화된 명령어 사용
  - 단순하고 적은 수의 고정 길이 명령어 집합을 활용
  - 명령어 파이프라이닝에 유리
    - 짧고 규격화된 명령어를 활용하기 때문.
  - 메모리 접근 최소화(load, store), 레지스터 최대한 활용
- 단점
  - 다만 명령어 종류가 CISC보다 적어 더 많은 명령어로 프로그램을 동작시킴

|                 CISC                 |                 RISC                 |
| :----------------------------------: | :----------------------------------: |
|        복잡하고 다양한 명령어        |         단순하고 적은 명령어         |
|           가변 길이 명령어           |           고정 길이 명령어           |
|        다양한 주소 지정 방식         |         적은 주소 지정 방식          |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
|     여러 클럭에 걸쳐 명령어 수행     |       1클럭 내외로 명령어 수행       |
|       파이프라이닝하기 어려움        |        파이프라이닝하기 쉬움         |

    현대 CISC 기반의 프로세서라고 할지라도 실제로 수행될 때 마이크로 명령어라해서 명령어 하나하나를 실행할 때 내부적으로 잘게 쪼개서 실행을 하는 경우도 많다. (기존 단점을 어느정도 보완)

# 6. 메모리와 캐시 메모리

## 1. RAM의 특징과 종류

### 1. DRAM(Dynamic RAM)

- Dynamic = '동적의'
- 저장된 데이터가 동적으로 사라지는 RAM
- 데이터 소멸을 막기 위해 주기적으로 재활성화해야 한다.
- 일반적으로 메모리로 사용되는 RAM이다.
  - 상대적으로 소비전력이 낮고 저렴하고 집적도가 높다.
  - 대용량으로 설계하기 용이하다.

### 2. SRAM(Static RAM)

- Static = '정적의'
- 저장된 데이터가 정적인 (사라지지 않는) RAM
- DRAM 보다 일반적으로 더 빠름
- 일반적으로 캐시 메모리에서 사용되는 RAM
  - 상대적으로 소비전력이 높고 가격이 높고 집적도가 낮다.
  - '대용량으로 설계할 필요는 없으나 빨라야 하는 장치'에 사용

|           |      DRAM       |    SRAM     |
| :-------: | :-------------: | :---------: |
|  재충전   |     필요함      |  필요 없음  |
|   속도    |      느림       |    빠름     |
|   가격    |     저렴함      |    비쌈     |
|  집적도   |      높음       |    낮음     |
| 소비 전력 |      적음       |    높음     |
| 사용 용도 | 주기억장치(RAM) | 캐시 메모리 |

### 3. SDRAM (Synchronous DRAM) (SDR SDRAM||Single Data Rate)

- 특별한 (발전된 형태의) DRAM
- 클럭 신호와 동기화된 DRAM

### 4. DDR SDRAM (Double Data Rate SDRAM)

- 특별한 (발전된 형태의) SDRAM
- 최근 가장 대중적으로 사용하는 RAM
- 대역폭을 넓혀 속도를 빠르게 만든 SDRAM
  - 대역폭은 데이터를 주고받는 길의 너비
  - DDR SDRAM = SDRAM(SDR SDRAM)의 2배
  - DDR2 SDRAM = DDR SDRAM의 2배 = SDRAM(SDR SDRAM)의 4배
  - DDR3 SDRAM = DDR2 SDRAM의 2배 = SDRAM(SDR SDRAM)의 8배
  - DDR4 SDRAM = DDR3 SDRAM의 2배 = SDRAM(SDR SDRAM)의 16배
- 현재 가장 대중적으로 사용되는 RAM이 DDR4 SDRAM이다.

## 2. 메모리의 주소 공간

    CPU와 실행 중인 프로그램은 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알고 있는가?

                No

    - 메모리에 저장된 값들은 시시각각 변하기 때문
      - 새롭게 실행되는 프로그램은 새롭게 메모리에 적재
      - 실행이 끝난 프로그램은 메모리에서 삭제
      - 같은 프로그램을 실행하더라도 실행할 때마다 적재되는 주소는 달라짐

    그렇기 때문에 이러한 점을 극복하기 위해서 주소체계를 물리 주소와 논리 주소로 나누었다.

### 1. 물리 주소

- 메모리 입장에서 바라본 주소
- 말 그대로 정보가 실제로 저장된 하드웨어상의 주소

### 2. 논리 주소

- CPU와 실행 중인 프로그램 입장에서 바라본 주소
- 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소

  ```markdown
                    논리 주소          물리 주소               메모리
            0번지 ____________       _____________ 0번지     ________
                |           |       |____________|          |_______|
                |  브라우저  |       |            | ⌉        |_______|
                |___________|       |  브라우저   | A        |_______|
            A번지                    |____________| ⌋        |_______|
                                    |____________|          |_______|
            0번지 ____________       |____________|         |_______|
                |           |       |____________|          |_______|
                |   게  임  |        |            | ⌉        |_______|
                |___________|       |   게  임    | B        |_______|
            B번지                    |____________| ⌋        |_______|
                                     |____________|          |_______|
            0번지 ____________       |____________|          |_______|
                |           |       |            | ⌉         |_______|
                | 메 모 장  |        |  메 모 장  | C         |_______|
                |___________|       |____________| ⌋         |_______|
            C번지                                  Z번지
  ```

- 논리 주소 상에는 여러 개의 겹치는 번지수가 존재한다.
  - 브라우저에서도 0번지, 게임에서도 0번지가 존재하고 100번지 또한 브라우저, 게임 각각에 존재할 수 있다.
- 물리 주소 상에는 여러 개의 겹치는 번지수가 존재하지 않는다.

### 3. 물리 주소와 논리 주소의 변환

- CPU가 이해하고 실행하는 주소는 다 논리 주소이다.
- MMU(메모리 관리 장치)라는 하드웨어에 의해 변환
  - CPU <--(논리주소)--> [ MMU ] <--(물리주소)--> 프로그램in메모리
- MMU는 논리 주소와 베이스 레지스터(프로그램의 기준 주소) 값을 더하여 논리 주소를 물리 주소로 변환
  - 베이스 레즈서터에는 시작 주소, 즉 물리 주소상의 프로그램의 시작 주소가 담긴다.
  - 논리 주소는 실제로 저장되어있는 프로그램으로 부터 얼마나 떨어져 있느냐에 해당하는 정보.
  - e.g.
    - A라는 프로그램은 1500번지 부터 3000번지까지 실제 물리주소상에 저장.
    - 1500번지는 베이스 레지스터에 담긴다.
    - 논리주소는 각 프로그램에 0번지부터 부여하는 주소이기 때문에
    - 논리주소가 100이라면 기준 주소로 부터 100 떨어져 있는 곳이라고 볼 수 있다.
    - 즉, 실제 물리주소상으로는 1500 + 100인 1600번지이다.

### 4. 메모리 보호

- 한계 레지스터
  - 프로그램의 영역을 침범할 수 있는 명령어를 막음
  - 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 논리 주소의 최대 크기를 저장
  - 베이스 레지스터 값 <= 프로그램의 물리 주소 범위 < 베이스 레지스터 + 한계 레지스터 값
    - 물리주소 100~300 이라면, 한계 레지스터의 값은 300-100인 200이다.
    - 베이스 레지스터(기준주소)와 논리 주소를 더한 값이 베이스 레지스터 값과 한계 레지스터를 합한 값인 300보다 크다면 해당 명령어의 실행을 막아준다.
  - CPU는 메모리에 접근하기 전 접근하고자 하는 논리 주소가 한계 레지스터 값보다 작은지를 항상 검사.
  - 이로써 실행 중인 프로그램의 독맂적인 실행 공간을 확보 & 하나의 프로그램이 다른 프로그램을 침범하지 못하게 보호

## 3. 캐시 메모리

    CPU가 메모리에 접근하는 속도는 CPU의 연산 속도보다 압도적으로 느리다.

### 1. 저장 장치 계층 구조 (메모리 계층 구조 | memory hierarchy)

- 용어 혼동 방지 차원에서 저장 장치라고 표현. (memory는 RAM이 아닌 일반적인 저장 장치를 의미)

1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
2. 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.

- 레지스터 vs 메모리(RAM) vs USB 메모리
  - 접근 시간
    - 레지스터 > RAM > USB 메모리
  - 가격
    - 레지스터 > RAM > USB 메모리
  - 용량
    - USB 메모리 > RAM > 레지스터
- 낮은 가격대의 대용량 저장 장치를 원한다면 느린 속도를 감수해야 한다.
- 빠른 속도의 저장 장치를 원한다면 작은 용량과 비싼 가격을 감수해야 한다.

### 2. 캐시메모리

- CPU와 메모리 사이에 위치한, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치
- CPU의 연산 속도와 메모리 접근 속도의 차이를 조금이나마 줄이기 위해 탄생.
- "CPU가 매번 메모리에 왔다 갔다 하는 건 시간이 오래 걸리니, 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 쓰자"

### 3. 캐시 메모리까지 반영한 저장 장치 계층 구조

- 레지스터 > 캐시 메모리(L1,L2,L3) > 메모리 > 보조 기억 장치
  - 빠름 <----속도-----> 느림
  - 작음 <----용량-----> 큼
  - 비쌈 <----가격-----> 저렴
- 계층적 캐시 메모리 (L1-L2-L3 캐시)
  - 일반적으로 L1 캐시와 L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치.
  - 속도 -> L1 > L2 > L3
  - 용량 -> L1 < L2 < L3
- 분리형 캐시
  - L1 캐시 메모리를 조금이라도 더 빨리 만들기 위해서 분리.
  - L1D 캐시 = 데이터만을 담고 있음.
  - L1I 캐시 = 명령어만을 담고 있음.
- 참조 지역성의 원리

       캐시 메모리는 메모리보다 용량이 작다. 당연하게도 메모리의 모든 내용을 저장할 수 없다.
      메모리에서 일부 내용만을 가져와서 저장할 수 밖에 없다.
      CPU가 자주 사용할 법한 내용을 예측해서 미리 갖고와야 한다.

  - 캐시 히트
    - 캐시 메모리의 예측이 들어 맞았을 경우, CPU가 캐시메모리가 가져온 데이터를 실제로 활용했을때
  - 캐시 미스
    - 예측이 틀렸을 경우. CPU가 메모리에 접근해야 하는 경우.
  - 캐시 적중률
    - 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)
    - 현대의 CPU는 못해도 80% 이상인 경우가 많다.
  - 참조 지역성의 원리란?
    - CPU가 사용할 법한 데이터를 예측하는 어떠한 원칙.
    - CPU가 메모리에 접근할 때의 주된 경향을 바탕으로 만들어진 원리
      1. CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
      2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.
         - 공간 지역성이라고도 불림
    - CPU는 참조 지역성의 원리를 바탕으로 캐시 적중률을 높인다.

# 7. 보조기억장치

## 1. 다양한 보조기억장치

### 1. 하드 디스크

- 자기적인 방식으로 데이터 저장
- 자기 디스크의 일종
- 구성
  - 스핀들
    - 플래터를 회전 시켜준다.
  - 플래터
    - 수많은 N극과 S극, 자기적인 물질로 덮여있는 판 (CD같이 생긴 판들)
    - 일반적으로 플래터 양면 모두 사용.
  - 헤드
    - 플래터와 미세하게 떠있는 자기 물질을 읽는 구성요소
    - 플래터 사이사이, 플래터 양면에 헤드가 존재
  - 디스크암
    - 헤드를 움직여 주는 구성 요소.
    - 일반적으로 모든 헤드가 디스크 암에 부착되어 함께 이동
- 저장 단위
  - 기본적으로 트랙(track)과 섹터(sector) 단위로 데이터 저장
    - 섹터의 크기 : 512 바이트 ~ 4096 바이트
    - 하나 이상의 섹터를 묶어 블록(block)이라고 표현하기도 한다.
  - 트랙(track)
    - 플래터를 이루고 있는, 동심원을 그리는 저장 단위.
  - 섹터(sector)
    - 트랙을 피자 조각처럼 나눈 구역 중 한 구역을 섹터라고 부른다.
  - 실린더
    - 여러 겹의 플래터 상에서 같은 트랙이 위치 한 곳을 모아 연결한 논리적 단위
    - 플래터는 트랙과 섹터로 나뉘고, 같은 트랙이 모여 실린더를 이룬다.
    - 연속된 정보는 한 실린더에 기록
- 데이터 접근 과정
  - 하드 디스크가 저장된 데이터에 접근하는 시간
    - 탐색 시간 (seek time)
      - 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
    - 회전 지연 (rotational latency)
      - 헤드가 있는 곳으로 플래터를 회전시키는 시간
    - 전송 시간 (transfer time)
      - 하드 디스크와 컴퓨터 간에 데이터를 전송하는 시간

### 2. 플래시 메모리

- 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치
  - 범용성이 넓기에 보조기억장치에'만' 속한다고 보기는 어려움.
- 종류
  - NAND 플래시 메모리
    - NAND 연산을 수행하는 회로.
    - NAND 게이트.
    - 오늘날 대용량 저장 장치로 많이 사용되는 플래시 메모리
  - NOR 플래시 메모리
    - NOR 연산을 수행하는 회로.
    - NOR 게이트.
- 단위
  - 셀(cell)
    - 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
    - 이 셀이 모이고 모여 수 MB, GB, TB 저장 장치가 된다.
- 종류

  - 한셀에 1비트를 저장 할 수 있는 플래시 메모리 : SLC
    - 한 셀로 두 개의 정보 표현 (1, 0)
    - 비트의 빠른 입출력
    - 긴 수명
    - 용량 대비 고가격
  - 2비트 : MLC
    - 한 셀로 네 개의 정보 표현 (대용량화 유리) (00,01,10,11)
    - SLC보다 느린 입출력, 짧은 수명, 저렴
    - 시중에 많이 사용 (MLC,TLC,QLC)
  - 3비트 : TLC
    - 한 셀로 여덟 개의 정보 표현 (대용량화 유리)
    - MLC보다 느린 입출력, 짧은 수명, 저렴
  - 4비트 : QLC

    |      구분      |  SLC   | MLC  |  TLC   |
    | :------------: | :----: | :--: | :----: |
    |    셀장 bit    |  1bit  | 2bit |  3bit  |
    |      수명      |  길다  | 보통 |  짧다  |
    | 읽기/쓰기 속도 | 빠르다 | 보통 | 느리다 |
    | 용량 대비 가격 |  높다  | 보통 |  낮다  |

- 저장 단위

  - 페이지(page)

    - 셀들이 모여서 페이지
    - 페이지의 상태

      - Free 상태
        - 어떠한 데이터도 저장하고 있지 않아 새로운 데이터를 저장할 수 있는 상태.
      - Valid 상태
        - 이미 유효한 데이터를 저장하고 있는 상태
      - Invalid 상태

        - 유효하지 않은 데이터(쓰레기값)를 저장하고 있는 상태

              플래시 메모리는 하드 디스크와 달리 덮어쓰기가 불가능

  - 블록(block)
    - 페이지들이 모여 블록
  - 플레인(plain)
    - 블록들이 모여 플레인
  - 다이(die)
    - 플레인들이 모여 다이
  - 읽기/쓰기 단위와 삭제 단위는 다르다.
    - 읽기와 쓰기는 페이지 단위로 이루어짐
    - 삭제는 (페이지보다 큰) 블록 단위로 이루어짐

- 가비지 컬렉션
  1. 유효한 페이지들만을 새로운 블록으로 복사
  2. 기존의 블록을 삭제

## 2. RAID의 정의와 종류

    1TB 하드 디스크 네 개로 RAID를 구성하면
    4TB 하드 디스크 한 개의 성능과 안전성을 능가할 수 있다.

### 1. RAID의 정의

- RAID(Redundant Array of Independent Disks)
- 하드 디스크와 SSD로 사용하는 기술
- 데이터의 안전성 혹은 높은 성능을 위해 여러 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술

### 2. RAID의 레벨(종류)

- RAID를 구성하는 기술
- RAID 0, RAID 1, RAID 2, RAID3, RAID 4, RAID 5, RAID 6
- 그로부터 파생된 RAID 10, RAID 50, ··· (네스틔드 레이드라고도 함)
- RAID 0 : 데이터를 단순히 나누어 저장하는 구성 방식
  - 저장되는 데이터가 하드 디스크 개수만큼 나뉘어 저장
  - 스트라입(stripe) : 마치 줄무늬처럼 분산되어 저장된 데이터
  - 스트라이핑(striping) : 분산하여 저장하는 것
  - 장점 : 입출력 속도의 향상
  - 단점 : 저장된 정보가 안전하지 않음
    - 디스크 하나에 문제가 생겼을 때.
- RAID 1
  - 미러링 (mirroring) : 복사본을 만드는 방식
  - 데이터를 쓸 때 원본과 복사본 두 군데에 씀 (느린 쓰기 속도)
  - 장점 : 백업과 복구가 쉽다.
  - 단점 : 하드 디스크 개수가 한정되었을 때 사용 가능한 용량이 적어짐
    - 복사본이 만들어지는 용량만큼 사용 불가 -> 많은 양의 하드 디스크 필요 -> 비용 증가
- RAID 4
  - (RAID 1처럼 완전한 복사본을 만드는 대신) 오류를 검출하고 복구하기 위한 정보를 저장
    - 오류를 검출하고 복구하기 위한 정보 : 패리티 비트
      - 원래 패리티 비트는 오류 검출만 가능할 뿐 복구는 불가능
      - 하지만 RAID에서 사용하는 패리티 비트는 오류의 복구도 가능
  - RAID 1보다 적은 하드 디스크로도 데이터를 안전하게 보관
  - 장점 : RAID 1보다 적은 하드디스크로 데이터를 안전하게 보관
  - 단점 : 패러티 디스크의 병목
- RAID 5
  - 패리티 정보를 분산하여 저장하는 방식
    - RAID 4는 패리티를 저장한 장치를 따로 두는 방식, RAID 5는 패리티를 분산하여 저장하는 방식
  - 장점 : 패러티 디스크의 병목현상 완화
- RAID 6

  - 두 종류의 패리티 (오류를 검출하고 복구할 수 있는 수단)
  - RAID 5보다 안전, 쓰기는 RAID 5보다 느림

        각 RAID 레벨마다 장단점이 존재.
        어떤 상황에서 무엇을 최우선으로 원하는지에 따라 최적의 RAID 레벨은 달라질 수 있다.
        각 RAID 레벨의 대략적인 구성과 특징을 아는 것이 중요

# 8. 입출력장치

## 1. 장치 컨트롤러와 장치 드라이버

    입출력장치는 컴퓨터 내부와 어떻게 데이터를 주고받는가
    이번 장에서 언급하는 입출력장치는 보조기억장치도 포함

- 입출력장치는 앞서 다룬 CPU나 메모리보다 다루기 더 까다롭다.
  1. 입출력장치의 종류는 너무나 다양하다.
     - 장치가 다양하면 장치마다 속도, 데이터 전송 형식 등도 다양하다.
     - 다양한 입출력장치와 정보를 주고받는 방식을 규격화하기 어렵다.
  2. 일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률은 낮다.
     - 전송률이란 데이터를 얼마나 빨리 교환할 수 있는지를 나타내는 지표
  - 이러한 이유로 입출력장치는 장치 컨트롤러를 통해 컴퓨터와 연결된다.

### 1. 장치 컨트롤러

- 입출력장치는 장치 컨트롤러를 통해 컴퓨터와 연결된다.
- 입출력 제어기(I/O controller), 입출력 모듈(I/O module)이라고도 불린다.

### 2. 장치 컨트롤러의 역할

- CPU와 입출력장치 간의 통신중개
  - 입출력 장치를 다루는 데 있어서 정보를 주고 받는 방식을 규격화 하기 어렵다.
  - cpu와 입출력장치 간의 통신을 중개해 줌으로써 일종의 번역가 역할을 수행한다.
  - 이로서 정보를 주고 받는 방식을 규격화하기 어렵다는 문제를 어느정도 해결할 수 있다.
- 오류 검출
- 데이터 버퍼링
  - 버퍼링
    - 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법

### 3. 장치 컨트롤러의 구조

- 장치 컨트롤러는 버스에 연결되어 정보를 주고받게 된다. 그 정보에는 크게 3가지가 있다. 그리고 각각은 각각의 레지스터에 담긴다.

  - 데이터(데이터 레지스터)
    - CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터 (버퍼의 역할)
    - RAM을 사용하기도 한다.
      - 최근에는 입출력장치 자체도 주고받을 데이터가 너무나도 많아짐
  - 상태(상태 레지스터)
    - 입출력장치가 입출력 작업을 할 준비가 되었는지 상태를 저장.
    - 입출력 작업이 완료되었는지 상태를 저장.
    - 입출력장치에 오류는 없는지 등의 상태 정보를 저장.
  - 제어(제어 레지스터)
    - 입출력장치가 수행할 내용에 대한 제어 정보 저장.

  ※ 상태 레지스터와 제어 레지스터는 하나의 레지스터(상태/제어 레지스터)로 사용되기도 한다.

### 4. 장치 드라이버

- 장치 컨트롤러의 동작을 감지하고 제어하는 프로그램.
- 장치 컨트롤러가 입출력 장치를 연결하기 위한 하드웨어적인 통로라면, 장치 드라이버는 입출력장치를 연결하기 위한 소프트웨어적인 통로

  ※ 장치 드라이버가 설치되어 있지 않다면 해당 입출력장치를 사용할 수 없다.

- 장치 드라이버는 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램.
- 컴퓨터(운영체제)가 연결된 장치의 드라이버를 인식하고 실행할 수 있다면 컴퓨터 내부와 정보를 주고받을 수 있다.
- 반대로 컴퓨터(운영체제)가 장치 드라이버를 인식하고나 실행할 수 없다면 그 장치는 컴퓨터 내부와 정보를 주고받을 수 없다.

## 2. 다양한 입출력방법

    세 가지 입출력 방식 : 프로그램 입출력, 인터럽트 기반 입출력, DMA 입출력

### 1. 프로그램 입출력

- 프로그램 속 명령어로 입출력장치를 제어하는 방법
- 입출력 명령어로써 장치 컨트롤러와 상호작용

e.g.
메모리에 저장된 정보를 하드 디스크에 백업
(= 하드 디스크에 새로운 정보 쓰기)

1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령 내보내기
2. 하드 디스크 컨트롤러는 하드 디스크 상태 확인 -> 상태 레지스터에 준비 완료 표시
3. 1. CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비 여부를 확인
4. 2. 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 쓰기
      ※ 백업 작업(쓰기 작업)이 끝나지 않았다면 3.1, 3.2가 계속 반복한다. 쓰기 작업이 완료되면 종료

- 프로그램 입출력 방식 : CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다.

  1.  메모리 맵 입출력

      - 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
      - 입출력 장치 접근 명령어 == 메모리 접근 명령어

             e.g.
             - 516번지 : 프린터 컨트롤러의 데이터 레지스터
             - 517번지 : 프린터 컨트롤러의 상태 레지스터
             - 518번지 : 하드 디스크 컨트롤러의 데이터 레지스터
             - 519번지 : 하드 디스크 컨트롤러의 상태 레지스터

             '516번지를 읽어 들여라' == 프린터 상태 읽기
             '518번지에 a를 써라' == 하드 디스크에 a 쓰기

  2.  고립형 입출력
      - 메모리를 위한 주소 공간과 입출력 장치를 위한 주소 공간을 분리하는 방법
      - 입출력 전용 명령어 사용.

  |              메모리 맵 입출력               |               고립형 입출력               |
  | :-----------------------------------------: | :---------------------------------------: |
  |  메모리와 입출력장치는 같은 주소 공간 사용  | 메모리 입출력장치는 분리된 주소 공간 사용 |
  |          메모리 주소 공간이 축소됨          |     메모리 주소 공간이 축소되지 않음      |
  | 메모리와 입출력장치에 같은 명령어 사용 가능 |          입출력 정용 명령어 사용          |

### 2. 인터럽트 기반 입출력

1. 하드웨어 인터럽트는 장치 컨트롤러에 의해 발생
2. 동시다발적인 인터럽트 : 입출력 장치가 많을 때를 가정해보자.

   - 인터럽트 발생 순서대로?
     - 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우
     - 현실적으로 모든 인터럽트를 순차적으로 처리할 수 없다.
     - 인터럽트 중에서도 우선 순위가 높은 인터럽트가 존재
   - 우선순위를 반영한 인터럽트

     - NMI(Non-Maskable-Interrupt)가 발생한 경우
     - 플래그 레지스터 속 인터럽트 비트를 비활성화한 채 인터럽트를 처리하는 경우.
     - PIC(Program Interrupt Controller)

       1. 여러 장치 컨트롤러에 연결되어(CPU와 장치 컨트롤러들의 사이에 위치)
       2. 장치 컨트롤러의 하드웨어 인터럽트의 순위를 판단한 뒤
       3. CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어

       ※ PIC는 NMI 우선순위까지 판단하지는 않음 (NMI는 PIC를 거치지 않고 다이렉트로 CPU로 간다.)

       - PIC는 여러개를 사용하는 경우가 많다.

### 3. DMA 입출력

    프로그램 입출력, 인터럽트 기반 입출력의 공통점?
    입출력장치와 메모리 간의 데이터 이동은 CPU가 주도하고 이동하는 데이터도 반드시 CPU를 거친다.
    가뜩이나 바쁜 CPU...
    하드 디스크 백업과 같이 대용량 데이터를 이동한다면?

1. DMA(Direct Memory Access)

   - CPU를 거치지 않고 입출력장치가 메모리에 접근하는 기능
   - 입출력 과정

     1. CPU는 DMA 컨트롤러에 입출력 작업을 명령
     2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
     3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림

     ※ 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근

   - CPU는 입출력 작업의 시작과 끝만 관여
   - 시스템 버스는 공용 자원이기에 동시 사용이 불가능.
     - CPU가 시스템 버스를 사용할 때 DMA 컨트롤러는 시스템 버스를 사용할 수 X
     - DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU가 시스템 버스를 사용할 수 X
   - 그렇기에 DMA 컨트롤러는 아래와 같은 방법으로 시스템 버스를 이용한다.
     - Cycle stealing 이라고도 불림
     1. DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
     2. CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용

### 4. 입출력 버스

    장치 컨트롤러가 시스템버스에 직접 연결되어도 괜찮을까?
        NO!!
    장치 컨트롤러가 시스템버스에 직접 연결되어 있으면 DMA 과정에서
    DMA 컨트롤러는 불필요하게 시스템버스를 두번씩이용하게 된다.
       e.g 메모리 내용을 읽어드리기 위해 한 번, 디스크에 쓰기 위해 한 번.
    시스템 버스는 공용으로 사용하지 못하기 때문에 어느 누가 시스템 버스를 오랫동안 점유하고
    있는 것은 결코 좋지 않다.

1. 입출력 버스

- 입출력 버스를 통해 시스템 버스의 이용 빈도를 낮춘다.
  - e.g. PCI 버스, PCI express(PCIe) 버스와 입출력 장치를 연결짓는 슬롯
  - 슬롯 -> 입출력 버스 -> 시스템 버스

# 9. 운영체제 시작하기

## 1. 운영체제를 알아야 하는 이유

### 1. 운영체제란

1. 운영체제
   - 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램
     - 실행할 프로그램에 필요한 자원을 할당.
     - 모든 프로그램은 실행을 위해 자원을 필요로 한다.
       - 리소스(시스템 자원) : 프로그램 실행에 있어서 마땅히 필요한 요소들.
       - 컴퓨터의 네 가지 핵심 부품 포함!
   - 운영체제 또한 프로그램이기에 메모리에 전재돼서 실행된다.
     - 운영체제는 커널 영역에 적재되는 프로그램이다.
       - 운영체제는 컴퓨터 동작에 있어서 매우 중요하고 특별한 프로그램이라 메모리에 따로 적재되는 영역이 존재.
       - 일반적인 프로그램, 즉 응용 프로그램은 사용자 영역에 적재.
         - 응용 프로그램 (application software) : 사용자가 특정 목적을 위해 사용하는 일반적인 프로그램
     - 메모리 영역들을 따지자면 크게 '커널 영영'과 '사용자 영영'으로 나눌 수 있다.
   - 운영체제의 메모리 관리.
     - 응용 프로그램을 메모리의 적당한 빈 공간에 적재
   - 운영체제의 CPU 관리.
     - 여러 응용 프로그램을 동시에 실행할 때, 어떤 프로그램부터 실행하고 어떤 순서로 실행 시킬지 운영체제가 결정.
   - 운영체제의 입출력장치 관리

## 2. 운영체제의 큰 그림

- 운영체제는 현존하는 프로그램 중 규모가 가장 큰 프로그램 중 하나.
- 운영체제가 제공하는 기능은 다양하나 가장 핵심적인 서비스가 존재.
  - 자원에 접근하고 조작하는 기능
  - 프로그램이 올바르고 안전하게 실행되게 하는 기능 등
- 이러한 운영체제의 핵심 서비스를 담당하는 부분을 커널(kernel)이라고 한다.

### 1. 커널이란?

1. 운영체제의 심장, 커널
   - 커널은 운영체제의 핵심 기능을 담담.
     - 유저 인터페이스는 커널에 포함되지 않지만 운영체제에는 포함.
   - 이중모드와 시스템 호출
     - 사용자가 실행하는 프로그램은 자원에 직접 접근할 수 있을까?
     - No! 자원에 직접 접근은 위험하다.
     - 운영체제는 응용 프로그램들이 자원에 접근하려 할 때 오직 자신을 통해서만 접근하도록 하여 자원을 보호
     - 이러한 문지기 모드는 이중 모드로서 구현
   - 이중 모드
     - cpu가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식
     - 사용자 모드
       - 운영체제 서비스를 제공받을 수 없는 실행 모드
       - 커널 영역의 코드를 실행할 수 없는 실행 모드
       - 자원 접근 불가
     - 커널 모드
       - 운영체제의 서비스를 제공받을 수 있는 실행 모드
       - 자원 접근을 비롯한 모든 명령어 실행 가능
     - 슈퍼바이저 플래그
       - 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지를 나타낸다.
         - 슈퍼바이저 플래그가 1일 경우 커널 모드로 실행 중임을 의미. 0일 경우 사용자 모드로 실행 중임을 의미
   - 시스템 호출
     - 커널 모드로 전환하여 실행하기 위해 호출
     - 일종의 소프트웨어 인터럽트
     - 시스템 호출을 하게 되면 운영체제의 서비스를 제공받을 수 있는 커널 모드로 전환.
       - 시스템 호출이 처리되는 방식은 하드웨어 인터럽트 처리 방식과 유사.

### 2. 운영체제의 서비스 종류

1. 프로세스 관리
   - 프로세스 == 실행 중인 프로그램
   - 수많은 프로세스들이 동시에 실행
   - 동시다발적으로 생성/실행/삭제되는 다양한 프로세스를 일목요연하게 관리
2. 자원 접근 및 할당
   - CPU
     - CPU 스케줄링 : 어떤 프로세스를 먼저, 얼마나 오래 실행할까?
   - 메모리
     - 페이징, 스와핑, ···
   - 입출력장치
     - 인터럽스 서비스 루틴
3. 파일 시스템 관리
   - 관련된 정보를 파일이라는 단위로 저장 장치에 보관
   - 파일들을 묶어 폴더(디렉토리) 단위로 저장 장치에 보관

# 10. 프로세스와 스레드

## 1. 프로세스 개요

### 1. 프로세스

- 프로세스는 실행중인 프로그램.
  1.  포그라운드 프로세스 (foreground process)
      - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
  2.  백그라운드 프로세스 (background process)
      - 사용자가 볼 수 없는 공간에서 실행되는 프로세스
      - 사용자와 상호작용하지 않고 그저 정해진 일만 수행하는 프로세스
        - 데몬 (daemon), 서비스 (service)

### 2. 프로세스 제어 블록

- 모든 프로세스는 실행을 위해 CPU가 필요하다
  - But, CPU 자원은 한정되어 있다.
- 프로세스들은 돌아가며 한정된 시간 만큼만 CPU 이용
  - 자신의 차례에 정해진 시간만큼 CPU 이용
  - 타이어 인터럽트가 발생하면 차례 양보
  - 빠르게 번갈아 수행되는 프로세스들을 관리해야한다.
- 이를 위해 사용하는 자료구조가 프로세스 제어 블록 (PCB)
  - 프로세스 관련 정보를 저장하는 자료 구조
  - 마치 상품에 달린 태그와 같은 정보
  - 프로세스 생성 시 커널 영역에 생성, 종료 시 폐기
- PCB에 담기는 대표적인 정보 (운영체제마다 차이가 있음.)
  - 프로세스 ID (=PID)
    - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호 (학교의 학번, 회사의 사번)
  - 레지스터 값
    - 프로세스는 자신의 실행 차례가 오면 이전까지 사용한 레지스터 중간 값을 모두 복원 -> 실행 재게
    - 프로그램 카운터, 스택 포인터 ···
  - 프로세스 상태
    - 입출력 장치를 사용하기 위해 기다리는 상태, CPU를 사용하기 위해 기다리는 상태, CPU 이용 중인 상태 ···
  - CPU 스케줄링 정보
    - 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
  - 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 페이지 테이블 정보
  - 사용한 파일과 입출력장치 정보
    - 할당된 입출력장치, 사용 중인(열린) 파일 정보

### 3. 문맥교환

- 한 프로세스 (e.g. 프로세스 A)에서 다른 프로세스(e.g. 프로세스 B)로 실행 순서가 넘어가면?
- 기존에 실행되던 프로세스 a는 지금까지의 중간 정보를 백업
  - 프로그램 카운터 등 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
  - 이러한 중간 정보 == 문맥 (context)
  - 뒤이어 실행할 프로세스 B의 문맥을 복구
    - 자연스럽게 실행 중인 프로세스가 바뀜
- 이처럼 기존의 실행중인 프로세스 문맥을 백업하고
- 새로운 프로세스 실행을 위해 문맥을 복구하는 과정을
- 문맥 교환 (context switching)이라 한다.
  - 여러 프로세스가 끊임없이 빠르게 번갈아 가며 실행되는 원리

### 4. 프로세스의 메모리 영역

- 그렇다면 사용자 영역에는?
- 사용자 영역
  - 크게 코드 영역 (=텍스트 영역), 데이터 영역, 힙 영역, 스택 영역
  - 코드 영역 (=텍스트 영역)
    - 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기가 금지된 영역 (read-only)
  - 데이터 영역
    - 잠깐 썼다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터 저장
    - e.g. 전역변수
  - 코드, 데이터 영역은 크기가 바뀌지 않는 영역, 정적할당 영역이라고 지칭하기도 함.
  - 힙 영역
    - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
    - 힙 영역에 할당한 이 메모리 공간을 언젠가 반환해주어야한다.
      - 이 기능을 가비지 컬렉션 (garbage collection)이라 한다.
    - 반환하지 않으면 계속해서 쌓이며 메모리 공간을 차지하면서 메모리의 낭비를 초래한다.
      - 이러한 문제를 메모리 누수 (MEMORY LEAK)라고 한다.
  - 스택 영역
    - 데이터가 일시적으로 저장되는 공간
    - (데이터가 영역에 담기는 값과는 달리) 잠깐 쓰다가 말 값들이 저장되는 공간
    - e.g. 매개 변수, 지역 변수
  - 힙, 스택 영역은 크기가 동적으로 변할 수 있다. 두 영역읋 하나로 묶어 동적할당 영역이라고도 함.
- 힙 영역과 스택 영역의 크기는 가변적
  - 일반적으로 힙 영역은 낮은 주소 -> 높은 주소로 할당
  - 일반적으로 스택 영역은 높은 주소 -> 낮은 주소로 할당

## 2. 프로세스 상태와 계층 구조

### 1. 프로세스 상태

    운영체제마다 조금씩 차이가 있음.

1. 생성 상태
   - 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
   - 준비가 완료되었다면 준비 상태로
2. 준비 상태
   - 당장이라도 CPU를 할당 받아 실행할 수 있지만
   - 자신의 차례가 아니기에 기다리는 상태
   - 자신의 차례가 된다면 실행 상태로 (=디스패치)
3. 실행 상태
   - CPU를 할당 받아 실행 중인 상태
   - 할당된 시간 모두 사용 시(타이머 인터럽트 발생 시) 준비 상태로
   - 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로
4. 대기 상태
   - 프로세스가 실행 도중 입출력장치를 사용하는 경우
   - 입출력 작업은 CPU에 비해 느리기에 이 경우 대기 상태로 접어듬
   - 입출력 작업이 끝나면 (입출력 완료 인터럽트를 받으면) 준비 상태로
5. 종료 상태
   - 프로세스가 종료된 상태
   - PCB, 프로세스의 메모리 영역 정리

### 2. 프로세스 계층 구조

- 프로세스 실행 도중 (시스템 호출을 통해) 다른 프로세스 생성 가능
- 새 프로세스를 생성한 프로세스 : 부모 프로세스
- 부모 프로세스에 의해 생성된 프로세스 : 자식 프로세스

  부모 프로세스와 자식 프로세스는 별개의 프로세스이므로 각기 다른 PID를 가짐.

  일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스 PID(PPID)를 명시하기도 한다.

  자식 프로세스는 또 다른 자식 프로세스를 낳고 그 프로세스가 또 다른 자식 프로세스를 낳고 ···

  -> 프로세스의 계층적인 구조가 형성된다.

### 3. 프로세스 생성 기법

    부모 프로세스는 자식 프로세스를 어떻게 만들어 내고, 자식 프로세스는 어떻게 자신만의 코드를 실행할까?

- 복제와 옷 갈아입기. (window와는 상관 x)
  - 부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 자식 프로세스로 생성 (복제)
  - 자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 다른 프로그램으로 교체 (옷 갈아입기)
- fork 시스템 호출
  - 복사본 (=자식 프로세스) 생성
  - 부모 프로세스의 자원 상속
- exec 시스템 호출
  - 메모리 공간을 새로운 프로그램으로 덮어쓰기
  - 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

## 3. 스레드

    스레드(thread)는 프로세스를 구성하는 실행 흐름의 단위
    하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.
    한 프로세스를 여러 개의 스레드로 동시에 실행시킬 수 있다. (e.g. 웹 브라우저 프로세스를 실행할 때 화면 출력, 입력, 검색 스레드로 역할을 나누어 동시에 실행시킬 수 있다.)

### 1. 프로세스와 스레드

- 스레드의 구성 요소
  - 스레드 ID, 프로그램 카운터를 비롯한 레지스터 값, 스택 등
  - 실행에 필요한 최소한의 정보
- 프로세스를 이루는 스레드들은 프로세스의 자원을 공유하면서 실행된다.

### 2. 멀티 프로세스와 멀티 스레드

    동일한 작업을 수행하는 단일 스레드 프로세스 여러 개 실행 (멀티 프로세스)
    VS
    하나의 프로세스를 여러 스레드로 실행 (멀티 스레드). 어떤 차이가 있을까?

- 프로세스끼리는 자원을 공유하지 않는다 -> 남남처럼 독립적으로 실행된다.
  - 프로세스끼리는 자원을 공유하지 않지만 스레드끼리는 같은 프로세스 내의 자원을 공유하면서 실행된다.
  - 프로세스를 fork하면 코드/데이터/힙 영역 등 모든 자원이 복제되어 저장됨
    - 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재.
      - fork를 세 번 네 번 하면 메모리에는 같은 프로세스가 통째로 세 개 네 개 적재된다.
- 스레드는 프로세스의 자원을 공유한다. -> 협력과 통신에 유리하다. (때로는 문제가 될 수도)
  - 스레드들은 각기 다른 스레드 ID, (별도의 실행을 위해 꼭 필요한) 프로그램 카운터 값을 포함한 레지스터 값, 스택을 가질 뿐 프로세스가 가지는 자원을 공유한다.
  - 멀티 프로세스의 경우 하나의 프로세스에 문제가 생겨도 자원을 공유하고 있지 않기에 다른 프로세스 실행에 문제가 되지 않는다.
  - 멀티 스레드의 경우 하나의 스레드에 문제가 생기면 자원을 공유하고 있기 때문에 전체 프로세스에 문제가 생길 수 있다.
- 프로세스끼리는 자원을 공유하지 않는다.
  - 프로세스 간에도 자원을 주고받을 수 있다. : 프로세스 간 통신 (IPC)
  - 파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신
    - e.g. 프로세스 A가 hello.txt에 글을 쓰고 프로세스 B가 hello.txt를 읽어드린다면 hello.txt라는 파일을 통해 두 개의 프로세스가 통신을 주고 받았다 라고 볼 수 있다.
- 스레드는 프로세스의 자원을 공유한다.

# 11. CPU 스케줄링

## 1. CPU 스케줄링 개요

- CPU 스케줄링
  - 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것.

### 1. 프로세스 우선순위 (priority)

    가장 공정한 CPU 스케줄링?
    CPU를 사용하고 싶어하는 프로세스들이 차례로 돌아가며?
    No! => 빨리 처리해야 하는 프로세스가 있기 때문
    (= 프로게스마다 우선 순위가 다르기 때문)

- 입출력 작업이 많은 프로세스(=입출력 집중 프로세스)의 우선 순위는 CPU 작업이 많은 프로세스(=CPU 집중 프로세스)의 우선순위보다 높다.
  - 입출력 집중 프로세스는 CPU 집중 프로세스보다 실행상태보다는 대기상태에 더 많이 머무르게 된다.
  - 입출력 작업이 많은 입출력 집중 프로세스의 우선순위를 높여서 빨리 처리를 해버리는게 CPU 집중 프로세스한테 CPU를 많이 할당하기에 좋다.
- 프로세스 우선순위
  - 상황, 프로세스가 요구하는 자원에 맞게 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해서 운영체제가 부여하는 것이 프로세스 우선순위이다.
  - 프로세스의 PCB에 저장된다.

### 2. 스케줄링 큐

- 프로세스 우선순위가 정해져 있지만 운영체제 입장에서 모든 프로세스의 PCB를 확인하여 우선순위를 찾는 과정은 매우 비효율적이다.
- 스케줄링 큐는 어떤 자원을 이용하고 싶어하는 프로세스들이 서는 줄과 같다.

※ 큐라고 하는 자료구조는 선입선출 (FIFO/first in, first out) 방식이다.

※ 스케줄링에서의 큐는 반드시 선입선출 방식일 필요는 없다.

- 운영체제는 메모리에 적재되고 싶은 새로운 프로세스들을 큐에 삽입시켜 줄을 세우고, CPU를 쓰고 싶은 새로운 프로세스들 또한 큐에 삽입해서 줄을 세우고 이러한 방식이 스케줄링 큐이다.
- 스케줄링 큐의 종류는 다양하다.
  - 대표적으로 준비 큐, 대기 큐.
  - 준비 큐
    - CPU를 이용하기 위해 기다리는 줄
    - 준비 상태에 접어든 프로세스들이 서는 줄
  - 대기 큐
    - 입출력장치를 이용하기 위해 기다리는 줄
    - 대기 상태에 접어든 프로세스들이 서는 줄
    - 입출력장치별로 큐를 만들어 같은 장치를 요구하는 프로세스들은 같은 큐에서 대기
- 입출력이 완료돼서 완료 인터럽트가 바생하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고 이 PCB의 상태를 대기 상태에서 준비상태로 변경한 다음에 대기 큐에서 제거하고 준비 큐에 넣어준다.

### 3. 선점형과 비선점형 스케줄링

    현재 프로세스를 실행중인데 우선순위가 높은 프로세스가 등장하여 CPU 할당을 요구한다면?

- 현재 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당 (선점형 스케줄링)
- 현재 CPU를 사용 중인 프로세스의 작업이 끝날 때까지 프로세스 기다리기 (비선점형 스케줄링)

1. 선점형 스케줄링 (preemptive scheduling)

   - 어떤 프로세스 하나가 CPU 자원을 독점해서 쓸 수 없는 스케줄링
   - 프로세스마다 정해진 시간만큼 CPU를 쓰게 하고 정해진 시간을 모두 써서 타임아웃 인터럽트가 발생하면 운영체제가 해당 프로세스로부터 CPU 자원을 뺏어서 다음 차례의 프로세스에게 CPU 자원을 넘겨주는 방식.
   - 장점
     - 어느 한 프로세스의 자원 독점을 막고 프로세스들에게 골고루 자원을 배분할 수 있다.
   - 단점
     - 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

2. 비선점형 스케줄링 (non-preemptive scheduling)
   - 어떤 프로세스가 한 자원을 이용하고 있을 때 해당 프로세스가 종료되거나 대기 상태에 접어들기 전에 다른 프로세스가 끼어들 수 없는 방식.
   - 장점
     - 선점형 스케줄링에 비해 문맥 교환에서 발생하는 오버헤드가 적다.
   - 단점
     - 모든 프로세스가 골고루 자원을 이용하기 어렵다.

## 2. CPU 스케줄링 알고리즘

CPU 스케줄링 알고리즘의 종류는 다양하고 운영체제마다 서로 다른 스케줄링 알고리즘을 사용.

1. 선입 선처리 스케줄링
   - FCFS (First Come First Served) 스케줄링
   - 단순히 준비 큐에 삽입된 순서대로 처리하는 비선점 스케줄링
   - 먼저 CPU를 요청한 프로세스부터 CPU 할당
   - 단점
     - 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 부작용(=호위 효과)
2. 최단 작업 우선 스케줄링

   - SJF (Shortest Job First) 스케줄링
   - 호위 효과를 방지
   - CPU 사용이 긴 프로세스는 나중에 실행, CPU 사용 시간이 짧은 프로세스는 먼저 실행
   - CPU 사용 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식

     ※선점형 스케줄링, 비선점형 스케줄링으로도 구현될 수 있지만 기본적으로 비선점형 스케줄링으로 구분된다.

3. 라운드 로빈 스케줄링

   - RR (Round Robin) 스케줄링
   - 선입 선처리 스케줄링 + 타임 슬라이스(time slice)
     - 타임 슬라이스 : 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
   - 정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링

     - 큐에 삽입된 프로세스들은 순서대로 CPU를 이용하되 정해진 시간만큼만 이용
     - 정해진 시간을 모두 사용하였음에도 아직 프로세스가 완료되지 않았다면 다시 큐의 맨 뒤에 삽입 (문맥교환)

     ※ 타임 슬라이스의 크기가 중요. 크기가 너무 크다면 선입 선처리 스케줄링과 다를게 없다. 호위 효과 발생.

     ※ 반대로 타임 슬라이스의 크기가 작다면 그만큼 문맥교환이 자주 발생하여 CPU의 부담이 너무 커지게 되는 우려가 있다.

4. 최소 잔여 시간 우선 스케줄링
   - SRT (Shortest Remaining Time) 스케줄링
   - 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링
     - 최단 작업 우선 스케줄링 : 작업 시간이 짧은 프로세스부터 처리하는 스케줄링 알고리즘
     - 라운드 로빈 스케줄링 : 정해진 타임 슬라이스만큼 돌아가며 사용하는 스케줄링 알고리즘
   - 정해진 시간만큼 CPU를 이용하되, 다음으로 CPU를 사용할 프로세스로는 남은 작업 시간이 가장 적은 프로세스 선택.
5. 우선순위 스케줄링
   - 프로세스들에 우선순위를 부여하고, 우선순위 높은 프로세스부터 실행
   - 우선순위가 같은 프로세스들은 선입 선처리로 스케줄링
   - 최단 작업 우선 스케줄링, 최소 잔여 시간 스케줄링 ⊂ 우선순위 스케줄링
   - 단점
     - 우선순위 스케줄링의 근본적인 문제점, 기아(starvation) 현상 (아사 현상)
     - 우선순위 높은 프로세스만 주구장창 실행
     - 우선순위 낮은 프로세스는 (준비 큐에 먼저 삽입되었음에도 불구하고) 실행 연기
   - 이를 방지하기 위한 기법 : 에이징 (aging)
     - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식
     - 대기 중인 프로세스의 우선순위를 마치 나이 먹듯 점차 증가시키는 방식
       - 우선순위가 낮아도 언젠가는 우선순위가 높아진다.
6. 다단계 큐 스케줄링
   - Multilevel queue 스케줄링
   - 우선순위 스케줄링의 발전된 형태
   - 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식
     - 우선순위가 가장 높은 큐에 있는 프로세스를 먼저 처리
     - 우선순위가 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스 처리
   - 단점
     - 큐 간의 이동이 불가
     - 우선순위 낮은 프로세스는 계속해서 실행 연기 우려
     - 기아 현상 발생 가능
7. 다단계 피드백 큐 스케줄링
   - Multilevel feedback queue 스케줄링
   - 다단계 큐 스케줄링의 발전된 형태
     - 큐 간의 이동이 가능한 다단계 큐 스케줄링
       - 다단계 큐 스케줄링에서는 기본적으로 큐 간의 이동 불가
         - 우선순위 낮은 프로세스는 계속해서 실행 연기 우려
         - 기아 현상 발생 가능
   - 먼저 들어온 프로세스는 최고 우선순위로 들어와 실행을 하고 타임 슬라이스 동안 실행을 못할 경우 다음 우선순위로 옮겨지는 방식. 완료가 안될 경우 그 다음으로 낮은 우선순위로 이동.
     - 자연스럽게 CPU 집중 프로세스의 우선순위는 상대적으로 낮아지고 입출력 집중 프로세스의 우선순위는 상대적으로 높아짐.
   - 다단계 피드백 큐에서의 에이징 기법 적용
     - 일정 이상 낮은 우선순위 큐에서 대기하고 있던 프로세스가 있었다면 해당 프로세스의 우선순위를 점차 높여 기아현상을 예방할 수 있다.
     - 즉, 어떤 프로세스의 CPU 시간이 길면 우선순위가 낮아지고 어떤 프로세스의 낮은 우선순위 큐에서 너무 오래 기다리면 우선순위를 높이는 방식
     - CPU 스케줄링 방식으로 알려져 있음.

# 12. 프로세스 동기화

## 1. 동기화란

동시다발적으로 실행되는 프로세스와 스레드들은 서로 협력하며 영향을 주고 받는다. 이 과정에서 자원의 일관성을 보장해야 한다.

프로세스들의 동기화를 고려해야 한다.

### 1. 동기화의 의미

- 공동의 목적을 위해 동시에 수행되는 프로세스

  - e.g. 워드 프로세서 프로그램
    - 맞춤법 검사 프로세스
    - 입력 내용을 화면에 출력하는 프로세스
    - ···

> 아무렇게나 마구 실행해도 괜찮을까? <br>
> No! 올바른 수행을 위해 프로세스들은 동기화되어야 한다. <br>
> ※ 실행의 문맥을 갖는 모든 대상은 동기화 대상이기에 스레드도 동기화 대상이다.

- (프로세스) 동기화란?
  - 프로세스들의 수행 시기를 맞추는 것
  - 실행 순서 제어
    - 프로세스를 올바른 순서대로 실행하기
  - 상호 배제
    - 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근하게 하기

1. 실행 순서 제어를 위한 동기화 : reader writer problem

   - Writer : Book.txt 파일에 값을 저장하는 프로세스
   - Reader : Book.txt 파일에 저장된 값을 읽어들이는 프로세스
   - Reader와 Writer 프로세스는 무작정 아무렇게나 실행되어선 안된다.
     - 실행의 순서가 있기 때문.
     - Reader 프로세스는 'Book.txt 안에 값이 존재한다.'는 특정 조건이 만족되어야만 실행 가능

2. 상호 배제를 위한 동기화 : Bank account problem
   - 공유가 불가능한 자원의 동시 사용을 피하기 위한 동기화
3. 공유 자원과 임계 구역
   - 공유 자원 : 여러 프로세스 혹은 스레드가 공유하는 자원
     - 전역 변수, 입출력장치, 보조기억장치, ···
   - 임계 구역 : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
     - 임계 구역에 진입하고자 하면 진입한 프로세스 이외에는 대기해야 한다.
     - 임계 구역에 동시에 접근하면 자원의 일관성이 깨질 수 있다.
       - 레이스 컨디션(race condition)이라고 한다.
   - 운영체제가 임계구역 문제를 해결하는 세 가지 원칙
     - (상호 배제를 위한 동기화를 위한 세 가지 원칙)
     1. 상호 배제 (mutual exclusion)
        - 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 들어올 수 없다.
     2. 진행 (progress)
        - 임계 구역에 어떤 프로세스도 진입하지 않았다면 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
     3. 유한 대기 (bounded waiting)
        - 한 프로세스가 임계 구역에 진입하고 싶다면 언젠가는 임게 구역에 들어올 수 있어야 한다.
        - (임계 구역에 들어오기 위해 무한정 대기해서는 안 된다.)

## 2. 동기화 기법

### 1. 뮤텍스 락

- 상호 배제를 위한 동기화 도구(자물쇠 역할), 뮤텍스 락
- 뮤텍스 락의 단순한 형태

  - 전역 변수 하나, 함수 두 개
  - 자물쇠 역할 : 프로세스들이 공유하는 전역 변수 lock
  - 임계 구역을 잠그는 역할 : acquire함수
  - 임계 구역의 잠금을 해제하는 역할 : release 함수

    ```c
    ※ 함수의 이름은 바뀌어도 됨.

    acquire() {
      while (lock == true)  /* 만약 임계 구역이 잠겨있다면 */
        ;                   /* `;` = 무한반복 */ /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
      lock = true;          /* 만약 임계 구역이 잠겨 있지 않다면 임계 구역 잠금 */
    }

    release() {
      lock = false;         /* 임계 구역 작업이 끝났으니 잠금 해제 */
    }
    ```

    ```c
    acquire();  // 자물쇠 잠겨 있는지 확인, 잠겨 있지 않다면 잠그고 들어가기
    //임계 구역  // 임계 구역에서의 작업 진행
    release();  // 자물쇠 반환
    ```

  - acquire 함수
    - 프로세스가 임계 구역에 진입하기 전에 호출
    - 임계 구역이 잠겨 있다면
      - 임계 구역이 열릴 때까지(lock이 false가 될 때까지) 임계 구역을 반복적으로 확인
    - 임계 구역이 열려 있다면
      - 임계 구역을 잠그기(lock을 true로 바꾸기)
  - release 함수
    - 임계 구역에서의 작업이 끝나고 호출
    - 현재 잠긴 임계 구역을 열기 (lock을 false로 바꾸기)
  - 문제
    - 바쁜 대기 (busy waiting)
      - 임계 구역이 잠겨있는지 계속 반복해서 확인하는 방식(바쁜 대기)은 좋은 방식이 아니다.

### 2. 세마포

아래 설명에서는 세마포의 종류 (이진 세마포, 카운팅 세마포) 중 카운팅 세마포를 다룬다.

- 좀 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러 개 있는 경우에도 적용 가능
- 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리기
- 임계 구역 앞에서 가도 좋다는 신호를 받으면 임계 구역 진입
- 세마포의 단순한 형태

  - 전역 변수 하나, 함수 두 개
  - 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역 변수 S
  - 임계 구역에 들어가도 좋은지, 기다려야 할지를 알려주는 wait함수
  - 임계 구역 앞에서 기다리는 프로세스에 '이제 가도 좋다'는 신호를 주는 signal함수

    ```c
    ※ 함수 이름은 바뀌어도 됨.
    wait();
    // 임계 구역
    signal();
    ```

    ```c
    wait() {
      while( S <= 0)  /* 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 */
      ;               /* 사용할 수 있는 자원이 있는지 반복적으로 확인하고, */
      S--;            /* 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1 감소시키고 임계 구역 진입 */
    }

    signal() {
      S++;            /* 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다.
    }
    ```

  - e.g. 세 개의 프로세스 P1, P2, P3가 두 개의 공유 자원(S=2)에 P1, P2, P3 순서로 접근한다고 가정
    1. 프로세스 P1 wait 호출. S는 현재 2이므로 S를 1 감소시키고 임계 구역 진입
    2. 프로세스 P2 wait 호출. S는 현재 1이므로 S를 1 감소시키고 임계 구역 진입
    3. 프로세스 P3 wait 호출. S는 현재 0이므로 무한히 반복하며 S 확인
    4. 프로세스 P1 임계 구역 작업 종료, signal() 호출. S를 1 증가
    5. 프로세스 P3 S가 1이 됨을 확인. S는 현재 1이므로 S를 1 감소시키고 임계 구역 진입
  - 문제
    - 바쁜 대기 (Busy waiting)
      - CPU 사이클 낭비
  - 해결 방법

    - 사용할 수 있는 자원이 없을 경우 대기 상태로 만듦.
      - (해당 프로세스의 PCB를 대기 큐에 삽입)
    - 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 준비 상태로 만듦
      - (해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐에 삽입)

    ```C
    wait() {
      S--;
      if ( S < 0 ) {
        add this process to Queue;  /* 해당 프로세스 PCB를 대기 큐에 삽입한다. */
        sleep();                    /* 대기 상태로 접어든다. */
      }
    }

    signal() {
      S++;
      if ( S <= 0 ) {
        remove a process p from Queue;  /* 대기 큐에 있는 프로세스 p를 제거한다. */
        wakeup(p);                      /* 프로세스 p를 대기 상태에서 준비 상태로 만든다. */
      }
    }
    ```

    1. 프로세스 P1 wait 호출. S를 1 감소시키면 S는 1이므로 임계 구역 진입
    2. 프로세스 P2 wait 호출. S를 1 감소시키면 S는 0이므로 임계 구역 진입
    3. 프로세스 P3 wait 호출. S를 1 감소시키면 S는 -1이므로 본인의 PCB를 대기 큐에 넣고 대기 상태로 전환
    4. 프로세스 P1 임계 구역 작업 종료, signal() 호출. S를 1 증가하면 0이므로 대기 상태였던 P3를 대기 큐에서 꺼내 준비 큐로 옮겨줌
    5. 깨어난 프로세스 P3 임계 구역 진입
    6. 프로세스 P2 임계 구역 작업 종료, signal() 호출. S가 1증가하면 1
    7. 프로세스 P3 임계 구역 작업 종료, signal() 호출. S가 1증가하면 2

- 세마포는 상호 배제를 위한 동기화뿐만 아니라 실행 순서 제어를 위한 동기화도 제공한다.
  - 세마포의 변수 S를 0으로 두고,
  - 먼저 실행할 프로세스 뒤에 signal 함수,
  - 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다.

### 3. 모니터

    매번 임계 구역 앞 뒤로 wait(), signal()을 호출해야 하나?
    그러다 실수라도 하면?
    프로그램 규모가 커지면 세마포를 누락하거나 wait, signal의 순서를 헷갈리거나 중복해서 사용하는 실수를 하게  되는 경우가 있다.
    그런 문제는 특히나 디버깅하기 어려운 경우가 많다.
    세마포는 사용자 입장에서 좀 번거롭다는 단점이 존재.

- 사용자(개발자)가 다루기에 편한 동기화 도구 (대표적인 언어 : Java)
- 상호 배제를 위한 동기화
  - 인터페이스를 위한 큐
  - 공유 자원에 접근하고자 하는 프로세스를 (인터페이스를 위한) 큐에 삽입
  - 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유 자원 이용
- 실행 순서 제어를 위한 동기화
  - 조건 변수(condition variable) 이용
    - 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
    - wait, signal을 호출할 수 있는 특별한 변수
    - 조건변수.wait() : 대기 상태로 변경, 조건 변수에 대한 큐에 삽입
    - 조건변수.signal() : wait()으로 대기 상태로 접어든 조건변수를 실행 상태로 변경
    - 모니터 안에는 하나의 프로세스만이 있을 수 있다.(두가지 방식이 있다.)
      - wait()를 호출했떤 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 수행을 재개.
      - signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤, 다시 signal()을 호출한 프로세스의 수행을 재개.
  1. 특정 프로세스가 아직 실행될 조건이 되지 않았을 때에는 wait를 통해 실행을 중단한다.
  2. 특정 프로세스가 실행될 조건이 충족되었을 때에는 signal을 통해 실행을 재개한다.
